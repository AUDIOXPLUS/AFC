<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-translate="Speaker Files">Speaker Files</title>
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/table.css">
    <link rel="stylesheet" href="css/filters.css">
    <link rel="stylesheet" href="css/modal.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/pages.css">
    <link rel="stylesheet" href="mobile.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        tr.selected {
            background-color: #ffcccb !important;
        }
        .lock-icon {
            margin-left: 5px;
            cursor: pointer;
            color: #ccc;
            transition: color 0.3s;
        }
        .lock-icon.locked {
            color: #dc3545; /* Rosso */
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="logo">AFC</div>
            <ul>
                <li><a href="projects.html" data-translate="Projects">Projects</a></li>
                <li><a href="#" onclick="openSpeakerDatabase(); return false;" class="active" data-translate="Speaker Database">Speaker Database</a></li>
                <li><a href="users.html" data-translate="Team Members">Team Members</a></li>
                <li><a href="tasks.html" data-translate="My Tasks">My Tasks</a></li>
                <li><a href="configuration.html" data-translate="Configuration">Configuration</a></li>
                <li><a href="https://afc-rd-631334295076.us-west1.run.app" target="_blank">AFC - R&D</a></li>
            </ul>
        </nav>
        <div class="user-info">
            <div class="notification-bell" id="notification-bell">
                <i class="fas fa-bell"></i>
                <span class="notification-count" style="display: none">0</span>
            </div>
            <a href="#" id="logout" data-translate="Logout">Logout</a>
        </div>
    </header>

    <main class="container">
        <section class="speaker-files-section">
            <h2 data-translate="Speaker Files">Speaker Files</h2>
            <div class="filters">
                <div class="filter-group">
                    <input type="text" id="client-filter" placeholder="Client" data-translate-placeholder="Client">
                    <label class="column-visibility"><input type="checkbox" data-column="0" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="product-kind-filter" placeholder="Product Kind" data-translate-placeholder="Product Kind">
                    <label class="column-visibility"><input type="checkbox" data-column="1" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="brand-filter" placeholder="Brand" data-translate-placeholder="Brand">
                    <label class="column-visibility"><input type="checkbox" data-column="2" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="range-filter" placeholder="Range" data-translate-placeholder="Range">
                    <label class="column-visibility"><input type="checkbox" data-column="3" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="line-filter" placeholder="Line" data-translate-placeholder="Line">
                    <label class="column-visibility"><input type="checkbox" data-column="4" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="model-filter" placeholder="Model N" data-translate-placeholder="Model N">
                    <label class="column-visibility"><input type="checkbox" data-column="5" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="filename-filter" placeholder="File Name" data-translate-placeholder="File Name">
                    <label class="column-visibility"><input type="checkbox" data-column="6" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="filekind-filter" placeholder="File Kind" data-translate-placeholder="File Kind">
                    <label class="column-visibility"><input type="checkbox" data-column="8" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="description-filter" placeholder="Description" data-translate-placeholder="Description">
                    <label class="column-visibility"><input type="checkbox" data-column="7" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="date-filter" placeholder="Date" data-translate-placeholder="Date">
                    <label class="column-visibility"><input type="checkbox" data-column="9" checked></label>
                </div>
                <div class="filter-group">
                    <button id="view-selected" title="View Selected"><i class="fas fa-eye"></i></button>
                    <button id="download-selected" title="Download Selected"><i class="fas fa-download"></i></button>
                </div>
            </div>
            <div class="table-wrapper">
                <table id="speaker-files-table" class="data-table">
                    <thead>
                    <tr>
                        <th data-translate="Client">Client <i class="fas fa-lock lock-icon" data-column="0"></i></th>
                        <th data-translate="Product Kind">Product Kind <i class="fas fa-lock lock-icon" data-column="1"></i></th>
                        <th data-translate="Brand">Brand <i class="fas fa-lock lock-icon" data-column="2"></i></th>
                        <th data-translate="Range">Range <i class="fas fa-lock lock-icon" data-column="3"></i></th>
                        <th data-translate="Line">Line <i class="fas fa-lock lock-icon" data-column="4"></i></th>
                        <th data-translate="Model N">Model N <i class="fas fa-lock lock-icon" data-column="5"></i></th>
                        <th data-translate="File Name">File Name <i class="fas fa-lock lock-icon" data-column="6"></i></th>
                        <th data-translate="Description">Description <i class="fas fa-lock lock-icon" data-column="7"></i></th>
                        <th data-translate="File Kind">File Kind <i class="fas fa-lock lock-icon" data-column="8"></i></th>
                        <th data-translate="Date">Date <i class="fas fa-lock lock-icon" data-column="9"></i></th>
                        <!-- Colonna Actions rimossa -->
                    </tr>
                    </thead>
                    <tbody>
                        <!-- I file verranno inseriti qui dinamicamente -->
                    </tbody>
                </table>
                <p id="filter-message" style="text-align: center; margin-top: 20px; color: #888;" data-translate="Write something in filters to display data">Write something in filters to display data</p>
                <div id="loading-animation" style="display: none; text-align: center; margin-top: 20px;">
                    <i class="fas fa-spinner fa-spin" style="font-size: 24px; color: #888;"></i>
                    <p style="color: #888;">Loading data...</p>
                </div>
            </div>
        </section>
    </main>

    <script src="version-log.js"></script>
    <script src="auth.js"></script>
    <script src="users.js"></script> <!-- Aggiunto users.js per displayLoggedInUser -->
    <script src="i18n.js"></script>
    <script src="menu-utils.js"></script>
    <script>
        let allFiles = []; // Array globale per memorizzare tutti i file
        let currentFilteredFiles = []; // Array per memorizzare i file filtrati correnti
        let lockedColumns = []; // Array per tracciare le colonne bloccate
        let lockedColumnsDirection = {}; // Oggetto per tracciare la direzione di ordinamento delle colonne bloccate
        let isLoading = false; // Flag per evitare caricamenti multipli
        let currentSortColumn = 5; // Default sort by Model N (index 5)
        let currentSortDirection = true; // true = ascending

        document.addEventListener('DOMContentLoaded', async function() {
            // Inizializza gli event listener per i lucchetti
            document.querySelectorAll('.lock-icon').forEach(icon => {
                icon.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const columnIndex = parseInt(this.getAttribute('data-column'));
                    this.classList.toggle('locked');
                    
                    if (this.classList.contains('locked')) {
                        if (!lockedColumns.includes(columnIndex)) {
                            lockedColumns.push(columnIndex);
                            // Salva la direzione corrente di ordinamento per questa colonna
                            // sortDirection contiene la direzione del PROSSIMO click, quindi l'attuale è l'opposto
                            lockedColumnsDirection[columnIndex] = !sortDirection[columnIndex];
                        }
                    } else {
                        lockedColumns = lockedColumns.filter(col => col !== columnIndex);
                        delete lockedColumnsDirection[columnIndex];
                    }
                    // Salva lo stato dei lucchetti e le direzioni nel localStorage
                    localStorage.setItem('lockedColumns', JSON.stringify(lockedColumns));
                    localStorage.setItem('lockedColumnsDirection', JSON.stringify(lockedColumnsDirection));
                });
            });
            displayLoggedInUser();
            initializeNotifications();
            initializeFilters();
            applyDefaultSorting();
            enableColumnResizing(); // Abilita il ridimensionamento delle colonne
        });

        // Funzione per salvare le larghezze delle colonne
        function saveColumnWidths() {
            const table = document.getElementById('speaker-files-table');
            const headerCells = table.getElementsByTagName('th');
            const widths = Array.from(headerCells).map(cell => cell.style.width);
            localStorage.setItem('speakerFilesColumnWidths', JSON.stringify(widths));
        }

        // Funzione per ripristinare le larghezze delle colonne
        function restoreColumnWidths() {
            const savedWidths = localStorage.getItem('speakerFilesColumnWidths');
            if (savedWidths) {
                const widths = JSON.parse(savedWidths);
                const table = document.getElementById('speaker-files-table');
                const headerCells = table.getElementsByTagName('th');

                widths.forEach((width, index) => {
                    if (headerCells[index] && width) {
                        headerCells[index].style.width = width;
                        // Aggiorna anche le celle del corpo della tabella
                        const tableRows = table.getElementsByTagName('tr');
                        for (let row of tableRows) {
                            if (row.cells[index]) {
                                row.cells[index].style.width = width;
                            }
                        }
                    }
                });
            }
        }

        function enableColumnResizing() {
            const table = document.getElementById('speaker-files-table');
            if (!table) return;
            
            const headerCells = table.getElementsByTagName('th');
            if (!headerCells || headerCells.length === 0) return;

            restoreColumnWidths();

            for (let i = 0; i < headerCells.length; i++) {
                const headerCell = headerCells[i];
                const resizer = document.createElement('div');
                resizer.className = 'resizer';
                headerCell.appendChild(resizer);

                let startX, startWidth;

                resizer.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    startX = e.clientX;
                    startWidth = headerCell.offsetWidth;

                    document.addEventListener('mousemove', resizeColumn);
                    document.addEventListener('mouseup', stopResize);
                    document.body.classList.add('column-resizing');
                });

                function resizeColumn(e) {
                    const widthChange = e.clientX - startX;
                    const newWidth = Math.max(50, startWidth + widthChange);
                    headerCell.style.width = `${newWidth}px`;

                    const tableRows = table.getElementsByTagName('tr');
                    for (let row of tableRows) {
                        if (row.cells[i]) {
                            row.cells[i].style.width = `${newWidth}px`;
                        }
                    }
                }

                function stopResize() {
                    document.removeEventListener('mousemove', resizeColumn);
                    document.removeEventListener('mouseup', stopResize);
                    document.body.classList.remove('column-resizing');
                    saveColumnWidths();
                }
            }
        }

        async function loadSpeakerFiles() {
            if (isLoading) return;
            isLoading = true;

            try {
                // Mostra l'animazione di caricamento
                const loadingAnimation = document.getElementById('loading-animation');
                loadingAnimation.style.display = 'block';
                
                // Garantire un ritardo minimo per mostrare l'animazione
                const minLoadingTime = new Promise(resolve => setTimeout(resolve, 1000));
                
                const response = await fetch('/api/files/speaker-files');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const files = await response.json();
                
                // L'API restituisce già solo i file rilevanti (TS/Graph) con il loro contenuto
                allFiles = files; 
                
                console.log(`Caricati ${files.length} file rilevanti`);
                
                // Aspetta il tempo minimo prima di nascondere l'animazione
                await minLoadingTime;
                
                // Nascondi l'animazione di caricamento
                loadingAnimation.style.display = 'none';

                // Applica i filtri correnti invece di mostrare tutto
                applyFilters();
            } catch (error) {
                console.error('Errore nel caricamento dei file speaker:', error);
                alert('Errore nel caricamento dei file. Riprova più tardi.');
                // Nascondi l'animazione di caricamento in caso di errore
                document.getElementById('loading-animation').style.display = 'none';
            } finally {
                isLoading = false;
            }
        }

        function initializeFilters() {
            // Aggiungi event listener per i filtri di testo
            const textFilters = [
                'client-filter', 'product-kind-filter', 'brand-filter', 
                'range-filter', 'line-filter', 'model-filter', 
                'filename-filter', 'filekind-filter', 'description-filter',
                'date-filter'
            ];
            
            // Ripristina i filtri salvati
            const savedFilters = JSON.parse(localStorage.getItem('speakerFilesFilters'));
            textFilters.forEach(filterId => {
                const filterElement = document.getElementById(filterId);
                if (filterElement) {
                    // Imposta il valore salvato se presente
                    if (savedFilters && savedFilters[filterId]) {
                        filterElement.value = savedFilters[filterId];
                    }
                    // Aggiungi event listener per salvare i filtri
                    filterElement.addEventListener('input', function() {
                        applyFilters();
                        saveFilters();
                    });
                }
            });
            
            // Applica i filtri se sono stati ripristinati
            if (savedFilters) {
                // Controlla se almeno un filtro ha un valore
                const hasActiveFilter = Object.values(savedFilters).some(value => value && value.trim() !== '');
                if (hasActiveFilter) {
                    // Carica automaticamente i dati se ci sono filtri attivi
                    loadSpeakerFiles().then(() => {
                        applyFilters();
                    });
                } else {
                    // Se non ci sono dati caricati, applyFilters non farà nulla di visibile ma imposterà lo stato
                    applyFilters();
                }
            }

            // Aggiungi event listener per le checkbox di visibilità colonne
            const columnCheckboxes = document.querySelectorAll('.column-visibility input[type="checkbox"]');
            columnCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', toggleColumnVisibility);
            });

            // Aggiungi event listener per il raggruppamento tramite click sull'intestazione della colonna
            enableColumnSorting();
            
            // Aggiungi event listener per i pulsanti "View Selected" e "Download Selected"
            const viewSelectedButton = document.getElementById('view-selected');
            if (viewSelectedButton) {
                viewSelectedButton.addEventListener('click', viewSelectedFiles);
            }
            
            const downloadSelectedButton = document.getElementById('download-selected');
            if (downloadSelectedButton) {
                downloadSelectedButton.addEventListener('click', downloadSelectedFiles);
            }
        }

        // Funzione per salvare i filtri nel localStorage
        function saveFilters() {
            const filters = {
                'client-filter': document.getElementById('client-filter')?.value || '',
                'product-kind-filter': document.getElementById('product-kind-filter')?.value || '',
                'brand-filter': document.getElementById('brand-filter')?.value || '',
                'range-filter': document.getElementById('range-filter')?.value || '',
                'line-filter': document.getElementById('line-filter')?.value || '',
                'model-filter': document.getElementById('model-filter')?.value || '',
                'filename-filter': document.getElementById('filename-filter')?.value || '',
                'filekind-filter': document.getElementById('filekind-filter')?.value || '',
                'description-filter': document.getElementById('description-filter')?.value || '',
                'date-filter': document.getElementById('date-filter')?.value || ''
            };
            localStorage.setItem('speakerFilesFilters', JSON.stringify(filters));
        }
        
        // Funzione per visualizzare i file selezionati
        function viewSelectedFiles() {
            const selectedRows = document.querySelectorAll('#speaker-files-table tbody tr.selected');
            if (selectedRows.length === 0) {
                alert('No files selected. Please select at least one file.');
                return;
            }
            
            const graphWindowName = 'graphViewer';
            let graphWindow = window.open('', graphWindowName);
            
            let checkInterval;
            const handleGraphViewerReady = (event) => {
                if (event.source === graphWindow && event.data && event.data.type === 'graphViewerReady') {
                    window.removeEventListener('message', handleGraphViewerReady);
                    clearInterval(checkInterval);
                    sendSelectedFilesToGraphWindow(graphWindow);
                }
            };

            if (!graphWindow || graphWindow.closed || !graphWindow.location || !graphWindow.location.href.includes('graph-viewer.html')) {
                graphWindow = window.open('graph-viewer.html', graphWindowName);
            } else {
                graphWindow.focus();
            }

            window.addEventListener('message', handleGraphViewerReady);

            let attempts = 0;
            checkInterval = setInterval(() => {
                attempts++;
                if (graphWindow && !graphWindow.closed) {
                    try {
                        graphWindow.postMessage({ type: 'areYouReady', targetWindowName: graphWindowName }, '*');
                    } catch (e) {
                        console.log("Finestra non ancora pronta...");
                    }
                } else {
                    clearInterval(checkInterval);
                    window.removeEventListener('message', handleGraphViewerReady);
                }
                
                if (attempts > 50) {
                    clearInterval(checkInterval);
                    window.removeEventListener('message', handleGraphViewerReady);
                    if (graphWindow && !graphWindow.closed) {
                        sendSelectedFilesToGraphWindow(graphWindow);
                    }
                }
            }, 100);
        }
        
        // Funzione per scaricare i file selezionati
        function downloadSelectedFiles() {
            const selectedRows = document.querySelectorAll('#speaker-files-table tbody tr.selected');
            if (selectedRows.length === 0) {
                alert('No files selected. Please select at least one file.');
                return;
            }
            
            selectedRows.forEach(row => {
                const fileId = row.dataset.fileId;
                window.open(`/api/files/${fileId}/download`, '_blank');
            });
        }

        function applyFilters() {
                const filters = {
                client: document.getElementById('client-filter')?.value.toLowerCase() || '',
                productKind: document.getElementById('product-kind-filter')?.value.toLowerCase() || '',
                brand: document.getElementById('brand-filter')?.value.toLowerCase() || '',
                range: document.getElementById('range-filter')?.value.toLowerCase() || '',
                line: document.getElementById('line-filter')?.value.toLowerCase() || '',
                model: document.getElementById('model-filter')?.value.toLowerCase() || '',
                filename: document.getElementById('filename-filter')?.value.toLowerCase() || '',
                filekind: document.getElementById('filekind-filter')?.value.toLowerCase() || '',
                description: document.getElementById('description-filter')?.value.toLowerCase() || '',
                date: document.getElementById('date-filter')?.value.toLowerCase() || ''
            };

            // Controlla se almeno un filtro è impostato
            const isFilterSet = filters.client || filters.productKind || filters.brand || filters.range || filters.line || filters.model || filters.filename || filters.filekind || filters.date;

            if (isFilterSet && allFiles.length === 0) {
                // Carica i dati solo se un filtro è impostato e i dati non sono ancora stati caricati
                loadSpeakerFiles();
            } else {
                currentFilteredFiles = allFiles.filter(file => {
                    return (
                        (!filters.client || (file.client || '').toLowerCase().includes(filters.client)) &&
                        (!filters.productKind || (file.productKind || '').toLowerCase().includes(filters.productKind)) &&
                        (!filters.brand || (file.brand || '').toLowerCase().includes(filters.brand)) &&
                        (!filters.range || (file.range || '').toLowerCase().includes(filters.range)) &&
                        (!filters.line || (file.line || '').toLowerCase().includes(filters.line)) &&
                        (!filters.model || (file.modelNumber || '').toLowerCase().includes(filters.model)) &&
                        (!filters.filename || (file.filename || '').toLowerCase().includes(filters.filename)) &&
                        (!filters.filekind || determineFileType(file.filename, file.content).toLowerCase().includes(filters.filekind)) &&
                        (!filters.description || (file.description || '').toLowerCase().includes(filters.description)) &&
                        (!filters.date || (file.upload_date ? new Date(file.upload_date).toLocaleDateString() : '').toLowerCase().includes(filters.date))
                    );
                });

                sortAndDisplayFiles();
            }
        }

        function toggleColumnVisibility() {
            const table = document.getElementById('speaker-files-table');
            const columnCheckboxes = document.querySelectorAll('.column-visibility input[type="checkbox"]');
            
            columnCheckboxes.forEach(checkbox => {
                const columnIndex = parseInt(checkbox.getAttribute('data-column'));
                const isVisible = checkbox.checked;
                
                // Nascondi/mostra header
                const headerCell = table.querySelector(`thead tr th:nth-child(${columnIndex + 1})`);
                if (headerCell) {
                    headerCell.style.display = isVisible ? '' : 'none';
                }
                
                // Nascondi/mostra celle delle righe
                const bodyCells = table.querySelectorAll(`tbody tr td:nth-child(${columnIndex + 1})`);
                bodyCells.forEach(cell => {
                    cell.style.display = isVisible ? '' : 'none';
                });
            });
        }

        function displayFiles(files) {
            const tbody = document.querySelector('#speaker-files-table tbody');
            tbody.innerHTML = '';
            const filterMessage = document.getElementById('filter-message');
            if (files.length === 0) {
                filterMessage.style.display = 'block';
            } else {
                filterMessage.style.display = 'none';
            }

            // Raggruppa i file per Model Number
            const groupedFiles = {};
            files.forEach(file => {
                const modelKey = file.modelNumber || 'Unknown Model';
                if (!groupedFiles[modelKey]) {
                    groupedFiles[modelKey] = [];
                }
                groupedFiles[modelKey].push(file);
            });

            Object.keys(groupedFiles).forEach(modelKey => {
                const group = groupedFiles[modelKey];
                const firstFile = group[0];
                const isGroup = group.length > 1;

                // Se c'è più di un file, crea una riga di gruppo
                if (isGroup) {
                    const groupRow = document.createElement('tr');
                    groupRow.classList.add('group-header');
                    groupRow.style.backgroundColor = '#f0f0f0';
                    groupRow.style.fontWeight = 'bold';
                    groupRow.style.cursor = 'pointer';

                    // Aggiungi icona di espansione alla prima cella (Client)
                    const clientCell = document.createElement('td');
                    clientCell.innerHTML = `<i class="fas fa-chevron-right expand-icon" style="margin-right: 5px;"></i> ${firstFile.client || '-'}`;
                    groupRow.appendChild(clientCell);

                    // Altre colonne comuni
                    const commonColumns = ['productKind', 'brand', 'range', 'line'];
                    commonColumns.forEach(col => {
                        const cell = document.createElement('td');
                        cell.textContent = firstFile[col] || '-';
                        groupRow.appendChild(cell);
                    });

                    // Colonna Model N - con link al progetto
                    const modelCell = document.createElement('td');
                    if (firstFile.modelNumber && firstFile.modelNumber !== '-' && firstFile.project_id) {
                        const modelLink = document.createElement('a');
                        modelLink.href = `project-details.html?id=${encodeURIComponent(firstFile.project_id)}`;
                        modelLink.textContent = firstFile.modelNumber;
                        modelLink.style.color = '#007bff';
                        modelLink.style.textDecoration = 'underline';
                        modelLink.style.cursor = 'pointer';
                        modelLink.title = `Visualizza dettagli progetto per ${firstFile.modelNumber}`;
                        modelLink.addEventListener('click', function(e) {
                            e.stopPropagation(); // Evita l'espansione quando si clicca sul link
                        });
                        modelCell.appendChild(modelLink);
                    } else {
                        modelCell.textContent = firstFile.modelNumber || '-';
                    }
                    groupRow.appendChild(modelCell);

                    // Colonne specifiche del file (File Name, Description, File Kind, Date) - mostrano riepilogo
                    const summaryCell = document.createElement('td');
                    summaryCell.colSpan = 4; // Occupa le restanti colonne
                    summaryCell.textContent = `${group.length} files`;
                    summaryCell.style.fontStyle = 'italic';
                    summaryCell.style.color = '#666';
                    groupRow.appendChild(summaryCell);

                    // Event listener per espandere/collassare
                    groupRow.addEventListener('click', function() {
                        const icon = this.querySelector('.expand-icon');
                        const isExpanded = icon.classList.contains('fa-chevron-down');
                        
                        // Toggle icona
                        icon.classList.remove(isExpanded ? 'fa-chevron-down' : 'fa-chevron-right');
                        icon.classList.add(isExpanded ? 'fa-chevron-right' : 'fa-chevron-down');

                        // Toggle visibilità righe figlie
                        let nextRow = this.nextElementSibling;
                        while (nextRow && nextRow.classList.contains('group-item')) {
                            nextRow.style.display = isExpanded ? 'none' : 'table-row';
                            nextRow = nextRow.nextElementSibling;
                        }
                    });

                    tbody.appendChild(groupRow);

                    // Aggiungi le righe dei singoli file (nascoste di default)
                    group.forEach(file => {
                        const row = createSingleFileRow(file);
                        row.classList.add('group-item');
                        row.style.display = 'none'; // Nascoste di default
                        // row.style.backgroundColor = '#ffffff'; // Rimosso per non sovrascrivere la selezione
                        
                        // Aggiungi indentazione alla prima cella
                        row.cells[0].style.paddingLeft = '30px';
                        
                        tbody.appendChild(row);
                    });

                } else {
                    // Se c'è un solo file, mostralo normalmente
                    const row = createSingleFileRow(firstFile);
                    tbody.appendChild(row);
                }
            });

            restoreColumnWidths();
        }

        function createSingleFileRow(file) {
            const row = document.createElement('tr');
            row.dataset.fileId = file.id;
            row.style.cursor = 'pointer';
            
            row.addEventListener('click', function(e) {
                if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'I' && e.target.tagName !== 'A') {
                    this.classList.toggle('selected');
                }
            });
            
            // Colonna Client
            const clientCell = document.createElement('td');
            clientCell.textContent = file.client || '-';
            row.appendChild(clientCell);
            
            // Colonna Product Kind
            const productKindCell = document.createElement('td');
            productKindCell.textContent = file.productKind || '-';
            row.appendChild(productKindCell);
            
            // Colonna Brand
            const brandCell = document.createElement('td');
            brandCell.textContent = file.brand || '-';
            row.appendChild(brandCell);
            
            // Colonna Range
            const rangeCell = document.createElement('td');
            rangeCell.textContent = file.range || '-';
            row.appendChild(rangeCell);
            
            // Colonna Line
            const lineCell = document.createElement('td');
            lineCell.textContent = file.line || '-';
            row.appendChild(lineCell);
            
            // Colonna Model N
            const modelCell = document.createElement('td');
            if (file.modelNumber && file.modelNumber !== '-' && file.project_id) {
                const modelLink = document.createElement('a');
                modelLink.href = `project-details.html?id=${encodeURIComponent(file.project_id)}`;
                modelLink.textContent = file.modelNumber;
                modelLink.style.color = '#007bff';
                modelLink.style.textDecoration = 'underline';
                modelLink.style.cursor = 'pointer';
                modelLink.title = `Visualizza dettagli progetto per ${file.modelNumber}`;
                modelLink.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
                modelCell.appendChild(modelLink);
            } else {
                modelCell.textContent = file.modelNumber || '-';
            }
            row.appendChild(modelCell);
            
            // Colonna File Name
            const nameCell = document.createElement('td');
            nameCell.textContent = file.filename;
            row.appendChild(nameCell);
            
            // Colonna Description
            const descriptionCell = document.createElement('td');
            descriptionCell.textContent = file.description || '-';
            row.appendChild(descriptionCell);
            
            // Colonna File Kind
            const fileKindCell = document.createElement('td');
            fileKindCell.textContent = determineFileType(file.filename, file.content);
            row.appendChild(fileKindCell);

            // Colonna Date
            const dateCell = document.createElement('td');
            if (file.upload_date) {
                const date = new Date(file.upload_date);
                dateCell.textContent = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            } else {
                dateCell.textContent = '-';
            }
            row.appendChild(dateCell);
            
            return row;
        }

        function determineFileType(filename, content) {
            if (filename.toLowerCase().endsWith('.txt')) {
                if (content) {
                    // Verifica se contiene parametri TS
                    if (checkForTSParameters(content)) {
                        return 'TS Parameters';
                    }
                    
                    // Verifica se contiene dati di risposta in frequenza o impedenza
                    const { dataType } = analyzeFileContent(content);
                    if (dataType === 'db') {
                        return 'Frequency Response';
                    } else if (dataType === 'ohm') {
                        return 'Impedance';
                    }
                }
                return 'Text File (content not loaded)';
            }
            return 'Other';
        }

        function checkForTSParameters(content) {
            const keywords = ["Fs", "Re", "Sd", "Qms", "Qes", "Qts", "Cms", "Mms", "Rms", "Bl", "dBspl", "VAS", "Zmin", "L1kHz", "L10kHz"];
            let count = 0;
            keywords.forEach(kw => {
                if (content.toLowerCase().includes(kw.toLowerCase())) {
                    count++;
                }
            });
            return count >= 3;
        }

        function analyzeFileContent(content) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let dataType = 'unknown';
            let startIndex = 0;

            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const lineForCheck = lines[i].toLowerCase();
                if (lineForCheck.includes('db')) {
                    dataType = 'db';
                } else if (lineForCheck.includes('ohm') || lineForCheck.includes('impedance')) {
                    dataType = 'ohm';
                }

                if (lineForCheck.includes('[') || lineForCheck.includes(']') || 
                    lineForCheck.includes('freq') || 
                    lineForCheck.includes('phase') || 
                    lineForCheck.includes('hz') ||
                    dataType !== 'unknown' ||
                    /^[a-zA-Z]/.test(lines[i])) {
                    startIndex = i + 1;
                } else {
                    const parts = lines[i].split(/[\s,;\t]+/).filter(p => p.length > 0);
                    const numericParts = parts.filter(p => !isNaN(parseFloat(p)) && isFinite(parseFloat(p)));
                    if (numericParts.length >= 2 && numericParts.length === parts.length) {
                        if (startIndex <= i) {
                            startIndex = i;
                        }
                        break;
                    } else {
                        startIndex = i + 1;
                    }
                }
            }
            return { dataType, startIndex };
        }

        function extractDataPoints(content, startIndex) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const points = [];
            
            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i];
                if (!line || line.startsWith('#') || line.startsWith('//')) {
                    continue;
                }
                const parts = line.split(/[\s,;\t]+/).filter(p => p.length > 0);
                if (parts.length >= 2) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    if (!isNaN(x) && isFinite(x) && !isNaN(y) && isFinite(y)) {
                        points.push({ x, y });
                    }
                }
            }
            return points;
        }

        async function viewFile(file) {
            // Controlla se ci sono righe selezionate
            const selectedRows = document.querySelectorAll('#speaker-files-table tbody tr.selected');
            if (selectedRows.length > 0) {
                const graphWindowName = 'graphViewer';
                let graphWindow = window.open('', graphWindowName);
                
                if (!graphWindow || graphWindow.closed || !graphWindow.location || !graphWindow.location.href.includes('graph-viewer.html')) {
                    graphWindow = window.open('graph-viewer.html', graphWindowName);
                    graphWindow.onload = () => sendSelectedFilesToGraphWindow(graphWindow);
                } else {
                    graphWindow.focus();
                    sendSelectedFilesToGraphWindow(graphWindow);
                }
            } else {
                // Se non ci sono righe selezionate, visualizza solo il file corrente
                await loadFileContent(file.id);
                openSingleFile(file);
            }
        }

        async function sendSelectedFilesToGraphWindow(targetWindow) {
            const selectedRows = document.querySelectorAll('#speaker-files-table tbody tr.selected');
            for (const row of selectedRows) {
                const fileId = row.dataset.fileId;
                const file = allFiles.find(f => f.id == fileId);
                if (file && file.filename.toLowerCase().endsWith('.txt')) {
                    try {
                        // Assicurati che il contenuto sia caricato
                        if (!file.content) {
                            await loadFileContent(file.id);
                        }
                        const content = file.content || '';
                        const { dataType, startIndex } = analyzeFileContent(content);
                        const points = extractDataPoints(content, startIndex);
                        
                        if (points.length > 0) {
                            targetWindow.postMessage({
                                type: 'addGraph',
                                points: points,
                                filename: file.filename,
                                dataType: dataType,
                                content: content
                            }, '*');
                        } else if (checkForTSParameters(content)) {
                            targetWindow.postMessage({
                                type: 'addGraph',
                                points: [],
                                filename: file.filename,
                                dataType: 'ts',
                                content: content
                            }, '*');
                        }
                    } catch (error) {
                        console.error(`Error processing "${file.filename}" as graph:`, error);
                    }
                }
            }
        }

        async function openSingleFile(file) {
            if (file.filename.toLowerCase().endsWith('.txt')) {
                try {
                    // Assicurati che il contenuto sia caricato
                    if (!file.content) {
                        await loadFileContent(file.id);
                    }
                    const content = file.content || '';
                    const { dataType, startIndex } = analyzeFileContent(content);
                    const points = extractDataPoints(content, startIndex);
                    
                    if (points.length > 0) {
                        const graphWindowName = 'graphViewer';
                        let graphWindow = window.open('', graphWindowName);
                        
                        const sendDataToGraphWindow = (targetWindow) => {
                            targetWindow.postMessage({
                                type: 'addGraph',
                                points: points,
                                filename: file.filename,
                                dataType: dataType,
                                content: content
                            }, '*');
                        };

                        let checkInterval;
                        const handleGraphViewerReady = (event) => {
                            if (event.source === graphWindow && event.data && event.data.type === 'graphViewerReady') {
                                window.removeEventListener('message', handleGraphViewerReady);
                                clearInterval(checkInterval);
                                sendDataToGraphWindow(graphWindow);
                            }
                        };

                        if (!graphWindow || graphWindow.closed || !graphWindow.location || !graphWindow.location.href.includes('graph-viewer.html')) {
                            graphWindow = window.open('graph-viewer.html', graphWindowName);
                        } else {
                            graphWindow.focus();
                        }

                        window.addEventListener('message', handleGraphViewerReady);

                        let attempts = 0;
                        checkInterval = setInterval(() => {
                            attempts++;
                            if (graphWindow && !graphWindow.closed) {
                                try {
                                    graphWindow.postMessage({ type: 'areYouReady', targetWindowName: graphWindowName }, '*');
                                } catch (e) {
                                    console.log("Finestra non ancora pronta...");
                                }
                            } else {
                                clearInterval(checkInterval);
                                window.removeEventListener('message', handleGraphViewerReady);
                            }
                            
                            if (attempts > 50) {
                                clearInterval(checkInterval);
                                window.removeEventListener('message', handleGraphViewerReady);
                                if (graphWindow && !graphWindow.closed) {
                                    sendDataToGraphWindow(graphWindow);
                                }
                            }
                        }, 100);

                    } else if (checkForTSParameters(content)) {
                        const graphWindowName = 'graphViewer';
                        let graphWindow = window.open('', graphWindowName);
                        
                        const sendDataToGraphWindow = (targetWindow) => {
                            targetWindow.postMessage({
                                type: 'addGraph',
                                points: [],
                                filename: file.filename,
                                dataType: 'ts',
                                content: content
                            }, '*');
                        };

                        let checkInterval;
                        const handleGraphViewerReady = (event) => {
                            if (event.source === graphWindow && event.data && event.data.type === 'graphViewerReady') {
                                window.removeEventListener('message', handleGraphViewerReady);
                                clearInterval(checkInterval);
                                sendDataToGraphWindow(graphWindow);
                            }
                        };

                        if (!graphWindow || graphWindow.closed || !graphWindow.location || !graphWindow.location.href.includes('graph-viewer.html')) {
                            graphWindow = window.open('graph-viewer.html', graphWindowName);
                        } else {
                            graphWindow.focus();
                        }

                        window.addEventListener('message', handleGraphViewerReady);

                        let attempts = 0;
                        checkInterval = setInterval(() => {
                            attempts++;
                            if (graphWindow && !graphWindow.closed) {
                                try {
                                    graphWindow.postMessage({ type: 'areYouReady', targetWindowName: graphWindowName }, '*');
                                } catch (e) {
                                    console.log("Finestra non ancora pronta...");
                                }
                            } else {
                                clearInterval(checkInterval);
                                window.removeEventListener('message', handleGraphViewerReady);
                            }
                            
                            if (attempts > 50) {
                                clearInterval(checkInterval);
                                window.removeEventListener('message', handleGraphViewerReady);
                                if (graphWindow && !graphWindow.closed) {
                                    sendDataToGraphWindow(graphWindow);
                                }
                            }
                        }, 100);

                    } else {
                        window.open(`/api/files/${file.id}/view`, '_blank');
                    }
                } catch (error) {
                    console.error(`Error opening "${file.filename}" as graph:`, error);
                    window.open(`/api/files/${file.id}/view`, '_blank');
                }
            } else {
                window.open(`/api/files/${file.id}/view`, '_blank');
            }
        }

        function downloadFile(fileId) {
            window.location.href = `/api/files/${fileId}/download`;
        }

        let sortDirection = []; // Variabile globale per tracciare la direzione di ordinamento

        // Funzione per abilitare l'ordinamento e il raggruppamento delle colonne
        function enableColumnSorting() {
            const table = document.getElementById('speaker-files-table');
            const headers = table.getElementsByTagName('th');
            sortDirection = Array(headers.length).fill(true); // true per ascendente, false per discendente

            // Carica l'ultimo stato di ordinamento dal localStorage
            const lastSorting = JSON.parse(localStorage.getItem('lastSpeakerFilesSorting'));
            if (lastSorting) {
                sortDirection[lastSorting.columnIndex] = lastSorting.direction;
                currentSortColumn = lastSorting.columnIndex;
                currentSortDirection = lastSorting.direction;
            }

            // Carica lo stato dei lucchetti salvato e le direzioni
            const savedLocks = JSON.parse(localStorage.getItem('lockedColumns'));
            const savedDirections = JSON.parse(localStorage.getItem('lockedColumnsDirection'));
            if (savedLocks) {
                lockedColumns = savedLocks;
                document.querySelectorAll('.lock-icon').forEach(icon => {
                    const colIndex = parseInt(icon.getAttribute('data-column'));
                    if (lockedColumns.includes(colIndex)) {
                        icon.classList.add('locked');
                        // Ripristina la direzione di ordinamento se salvata
                        if (savedDirections && savedDirections[colIndex] !== undefined) {
                            lockedColumnsDirection[colIndex] = savedDirections[colIndex];
                            // sortDirection deve essere l'opposto dell'attuale per il prossimo click
                            sortDirection[colIndex] = !savedDirections[colIndex];
                        }
                    }
                });
            }

            for (let i = 0; i < headers.length; i++) { // Itera su tutte le colonne
                headers[i].addEventListener('click', function() {
                    const columnIndex = i;
                    
                    // Se la colonna è bloccata, non fare nulla
                    if (lockedColumns.includes(columnIndex)) {
                        return;
                    }

                    const isAscending = sortDirection[columnIndex];
                    
                    // Aggiorna stato globale
                    currentSortColumn = columnIndex;
                    currentSortDirection = isAscending;

                    // Esegui l'ordinamento
                    sortAndDisplayFiles();

                    // Salva l'ultimo ordinamento nel localStorage
                    localStorage.setItem('lastSpeakerFilesSorting', JSON.stringify({
                        columnIndex: columnIndex,
                        direction: !isAscending // Salva la prossima direzione
                    }));

                    sortDirection[columnIndex] = !isAscending; // Cambia direzione di ordinamento per il prossimo click
                });
            }
        }

        function sortAndDisplayFiles() {
            const table = document.getElementById('speaker-files-table');
            const headers = table.getElementsByTagName('th');
            
            // Rimuovi la classe sorted da tutti gli header
            Array.from(headers).forEach(header => header.classList.remove('sorted'));
            // Aggiungi la classe sorted all'header corrente
            if (headers[currentSortColumn]) {
                headers[currentSortColumn].classList.add('sorted');
            }

            // Mappa indice colonna a proprietà oggetto file
            const columnMap = {
                0: 'client',
                1: 'productKind',
                2: 'brand',
                3: 'range',
                4: 'line',
                5: 'modelNumber',
                6: 'filename',
                7: 'description',
                8: 'filekind', // Calcolato
                9: 'upload_date'
            };

            const prop = columnMap[currentSortColumn];

            currentFilteredFiles.sort((a, b) => {
                // Prima verifica tutte le colonne bloccate in ordine cronologico di blocco
                for (const lockedCol of lockedColumns) {
                    const lockedProp = columnMap[lockedCol];
                    let aVal = a[lockedProp] || '';
                    let bVal = b[lockedProp] || '';
                    
                    if (lockedCol === 8) { // File Kind
                        aVal = determineFileType(a.filename, a.content);
                        bVal = determineFileType(b.filename, b.content);
                    }

                    const compareResult = String(aVal).localeCompare(String(bVal));
                    if (compareResult !== 0) {
                        // Usa la direzione salvata per questa colonna bloccata
                        const direction = lockedColumnsDirection[lockedCol];
                        return direction ? compareResult : -compareResult;
                    }
                }

                // Se tutte le colonne bloccate sono uguali, ordina per la colonna corrente
                // Solo se la colonna corrente non è bloccata
                if (!lockedColumns.includes(currentSortColumn)) {
                    let aVal = a[prop] || '';
                    let bVal = b[prop] || '';

                    if (currentSortColumn === 8) { // File Kind
                        aVal = determineFileType(a.filename, a.content);
                        bVal = determineFileType(b.filename, b.content);
                    }

                    return currentSortDirection ? String(aVal).localeCompare(String(bVal)) : String(bVal).localeCompare(String(aVal));
                }

                return 0;
            });

            displayFiles(currentFilteredFiles);
        }

        // Funzione per applicare l'ultimo ordinamento salvato
        function applyLastSorting() {
            const lastSorting = JSON.parse(localStorage.getItem('lastSpeakerFilesSorting'));
            if (lastSorting) {
                currentSortColumn = lastSorting.columnIndex;
                currentSortDirection = !lastSorting.direction; // Nota: direction salvata è la prossima, quindi invertiamo
                sortAndDisplayFiles();
            }
        }

        // Funzione per applicare l'ordinamento predefinito a Model N
        function applyDefaultSorting() {
            const lastSorting = JSON.parse(localStorage.getItem('lastSpeakerFilesSorting'));
            // Se non c'è un ordinamento salvato, imposta Model N come predefinito
            if (!lastSorting) {
                currentSortColumn = 5; // Model N
                currentSortDirection = true; // Ascending
                
                // Salva l'ordinamento predefinito nel localStorage
                localStorage.setItem('lastSpeakerFilesSorting', JSON.stringify({
                    columnIndex: 5,
                    direction: true
                }));
                
                sortAndDisplayFiles();
            } else {
                applyLastSorting();
            }
        }

        // La funzione adjustColumnWidths non è più necessaria, il ridimensionamento manuale la sostituisce.
        
        // Funzione per caricare il contenuto di un file specifico
        async function loadFileContent(fileId) {
            try {
                const contentResponse = await fetch(`/api/files/${fileId}/content`);
                if (contentResponse.ok) {
                    const content = await contentResponse.text();
                    // Aggiorna il contenuto nel array allFiles
                    const fileIndex = allFiles.findIndex(f => f.id == fileId);
                    if (fileIndex !== -1) {
                        allFiles[fileIndex].content = content;
                    }
                    return content;
                } else {
                    throw new Error(`HTTP error! status: ${contentResponse.status}`);
                }
            } catch (err) {
                console.warn(`Impossibile caricare il contenuto del file con ID ${fileId}:`, err);
                return '';
            }
        }
    </script>
</body>
</html>
