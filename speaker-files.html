<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-translate="Speaker Files">Speaker Files</title>
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/table.css">
    <link rel="stylesheet" href="css/filters.css">
    <link rel="stylesheet" href="css/modal.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/pages.css">
    <link rel="stylesheet" href="mobile.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        tr.selected {
            background-color: #ffcccb;
        }
        .lock-icon {
            margin-left: 5px;
            cursor: pointer;
            color: #ccc;
            transition: color 0.3s;
        }
        .lock-icon.locked {
            color: #007bff;
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="logo">AFC</div>
            <ul>
                <li><a href="projects.html" data-translate="Projects">Projects</a></li>
                <li><a href="#" onclick="openSpeakerDatabase(); return false;" class="active" data-translate="Speaker Database">Speaker Database</a></li>
                <li><a href="users.html" data-translate="Team Members">Team Members</a></li>
                <li><a href="tasks.html" data-translate="My Tasks">My Tasks</a></li>
                <li><a href="configuration.html" data-translate="Configuration">Configuration</a></li>
            </ul>
        </nav>
        <div class="user-info">
            <div class="notification-bell" id="notification-bell">
                <i class="fas fa-bell"></i>
                <span class="notification-count" style="display: none">0</span>
            </div>
            <a href="#" id="logout" data-translate="Logout">Logout</a>
        </div>
    </header>

    <main class="container">
        <section class="speaker-files-section">
            <h2 data-translate="Speaker Files">Speaker Files</h2>
            <div class="filters">
                <div class="filter-group">
                    <input type="text" id="client-filter" placeholder="Client" data-translate-placeholder="Client">
                    <label class="column-visibility"><input type="checkbox" data-column="0" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="product-kind-filter" placeholder="Product Kind" data-translate-placeholder="Product Kind">
                    <label class="column-visibility"><input type="checkbox" data-column="1" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="brand-filter" placeholder="Brand" data-translate-placeholder="Brand">
                    <label class="column-visibility"><input type="checkbox" data-column="2" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="range-filter" placeholder="Range" data-translate-placeholder="Range">
                    <label class="column-visibility"><input type="checkbox" data-column="3" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="line-filter" placeholder="Line" data-translate-placeholder="Line">
                    <label class="column-visibility"><input type="checkbox" data-column="4" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="model-filter" placeholder="Model N" data-translate-placeholder="Model N">
                    <label class="column-visibility"><input type="checkbox" data-column="5" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="filename-filter" placeholder="File Name" data-translate-placeholder="File Name">
                    <label class="column-visibility"><input type="checkbox" data-column="6" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="filekind-filter" placeholder="File Kind" data-translate-placeholder="File Kind">
                    <label class="column-visibility"><input type="checkbox" data-column="7" checked></label>
                </div>
                <div class="filter-group">
                    <input type="text" id="description-filter" placeholder="Description" data-translate-placeholder="Description">
                    <label class="column-visibility"><input type="checkbox" data-column="8" checked></label>
                </div>
                <div class="filter-group">
                    <button id="view-selected" title="View Selected"><i class="fas fa-eye"></i></button>
                    <button id="download-selected" title="Download Selected"><i class="fas fa-download"></i></button>
                </div>
            </div>
            <div class="table-wrapper">
                <table id="speaker-files-table" class="data-table">
                    <thead>
                    <tr>
                        <th data-translate="Client">Client <i class="fas fa-lock lock-icon" data-column="0"></i></th>
                        <th data-translate="Product Kind">Product Kind <i class="fas fa-lock lock-icon" data-column="1"></i></th>
                        <th data-translate="Brand">Brand <i class="fas fa-lock lock-icon" data-column="2"></i></th>
                        <th data-translate="Range">Range <i class="fas fa-lock lock-icon" data-column="3"></i></th>
                        <th data-translate="Line">Line <i class="fas fa-lock lock-icon" data-column="4"></i></th>
                        <th data-translate="Model N">Model N <i class="fas fa-lock lock-icon" data-column="5"></i></th>
                        <th data-translate="File Name">File Name <i class="fas fa-lock lock-icon" data-column="6"></i></th>
                        <th data-translate="Description">Description <i class="fas fa-lock lock-icon" data-column="7"></i></th>
                        <th data-translate="File Kind">File Kind <i class="fas fa-lock lock-icon" data-column="8"></i></th>
                        <!-- Colonna Actions rimossa -->
                    </tr>
                    </thead>
                    <tbody>
                        <!-- I file verranno inseriti qui dinamicamente -->
                    </tbody>
                </table>
                <p id="filter-message" style="text-align: center; margin-top: 20px; color: #888;" data-translate="Write something in filters to display data">Write something in filters to display data</p>
                <div id="loading-animation" style="display: none; text-align: center; margin-top: 20px;">
                    <i class="fas fa-spinner fa-spin" style="font-size: 24px; color: #888;"></i>
                    <p style="color: #888;">Loading data...</p>
                </div>
            </div>
        </section>
    </main>

    <script src="version-log.js"></script>
    <script src="auth.js"></script>
    <script src="users.js"></script> <!-- Aggiunto users.js per displayLoggedInUser -->
    <script src="i18n.js"></script>
    <script src="menu-utils.js"></script>
    <script>
        let allFiles = []; // Array globale per memorizzare tutti i file
        let lockedColumns = []; // Array per tracciare le colonne bloccate
        let lockedColumnsDirection = {}; // Oggetto per tracciare la direzione di ordinamento delle colonne bloccate
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Inizializza gli event listener per i lucchetti
            document.querySelectorAll('.lock-icon').forEach(icon => {
                icon.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const columnIndex = parseInt(this.getAttribute('data-column'));
                    this.classList.toggle('locked');
                    
                    if (this.classList.contains('locked')) {
                        if (!lockedColumns.includes(columnIndex)) {
                            lockedColumns.push(columnIndex);
                            // Salva la direzione corrente di ordinamento per questa colonna
                            lockedColumnsDirection[columnIndex] = sortDirection[columnIndex];
                        }
                    } else {
                        lockedColumns = lockedColumns.filter(col => col !== columnIndex);
                        delete lockedColumnsDirection[columnIndex];
                    }
                    // Salva lo stato dei lucchetti e le direzioni nel localStorage
                    localStorage.setItem('lockedColumns', JSON.stringify(lockedColumns));
                    localStorage.setItem('lockedColumnsDirection', JSON.stringify(lockedColumnsDirection));
                });
            });
            displayLoggedInUser();
            initializeNotifications();
            initializeFilters();
            applyDefaultSorting();
            enableColumnResizing(); // Abilita il ridimensionamento delle colonne
        });

        // Funzione per salvare le larghezze delle colonne
        function saveColumnWidths() {
            const table = document.getElementById('speaker-files-table');
            const headerCells = table.getElementsByTagName('th');
            const widths = Array.from(headerCells).map(cell => cell.style.width);
            localStorage.setItem('speakerFilesColumnWidths', JSON.stringify(widths));
        }

        // Funzione per ripristinare le larghezze delle colonne
        function restoreColumnWidths() {
            const savedWidths = localStorage.getItem('speakerFilesColumnWidths');
            if (savedWidths) {
                const widths = JSON.parse(savedWidths);
                const table = document.getElementById('speaker-files-table');
                const headerCells = table.getElementsByTagName('th');

                widths.forEach((width, index) => {
                    if (headerCells[index] && width) {
                        headerCells[index].style.width = width;
                        // Aggiorna anche le celle del corpo della tabella
                        const tableRows = table.getElementsByTagName('tr');
                        for (let row of tableRows) {
                            if (row.cells[index]) {
                                row.cells[index].style.width = width;
                            }
                        }
                    }
                });
            }
        }

        function enableColumnResizing() {
            const table = document.getElementById('speaker-files-table');
            if (!table) return;
            
            const headerCells = table.getElementsByTagName('th');
            if (!headerCells || headerCells.length === 0) return;

            restoreColumnWidths();

            for (let i = 0; i < headerCells.length; i++) {
                const headerCell = headerCells[i];
                const resizer = document.createElement('div');
                resizer.className = 'resizer';
                headerCell.appendChild(resizer);

                let startX, startWidth;

                resizer.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    startX = e.clientX;
                    startWidth = headerCell.offsetWidth;

                    document.addEventListener('mousemove', resizeColumn);
                    document.addEventListener('mouseup', stopResize);
                    document.body.classList.add('column-resizing');
                });

                function resizeColumn(e) {
                    const widthChange = e.clientX - startX;
                    const newWidth = Math.max(50, startWidth + widthChange);
                    headerCell.style.width = `${newWidth}px`;

                    const tableRows = table.getElementsByTagName('tr');
                    for (let row of tableRows) {
                        if (row.cells[i]) {
                            row.cells[i].style.width = `${newWidth}px`;
                        }
                    }
                }

                function stopResize() {
                    document.removeEventListener('mousemove', resizeColumn);
                    document.removeEventListener('mouseup', stopResize);
                    document.body.classList.remove('column-resizing');
                    saveColumnWidths();
                }
            }
        }

        async function loadSpeakerFiles() {
            try {
                // Mostra l'animazione di caricamento
                const loadingAnimation = document.getElementById('loading-animation');
                loadingAnimation.style.display = 'block';
                
                // Garantire un ritardo minimo per mostrare l'animazione
                const minLoadingTime = new Promise(resolve => setTimeout(resolve, 1000));
                
                const response = await fetch('/api/files/speaker-files');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const files = await response.json();
                
                // Carica il contenuto dei file per poterli filtrare
                const filesWithContent = await Promise.all(files.map(async (file) => {
                    try {
                        const contentResponse = await fetch(`/api/files/${file.id}/content`);
                        if (contentResponse.ok) {
                            const content = await contentResponse.text();
                            return { ...file, content: content };
                        }
                    } catch (err) {
                        console.warn(`Impossibile caricare il contenuto del file ${file.filename}:`, err);
                    }
                    return { ...file, content: '' };
                }));
                
                // Filtra solo i file con parametri TS, risposte in frequenza e impedenza
                const filteredFiles = filesWithContent.filter(file => {
                    if (!file.content) return false;
                    
                    // Verifica se contiene parametri TS
                    const hasTS = checkForTSParameters(file.content);
                    if (hasTS) return true;
                    
                    // Verifica se contiene dati di risposta in frequenza o impedenza
                    const { dataType } = analyzeFileContent(file.content);
                    return dataType === 'db' || dataType === 'ohm';
                });
                
                allFiles = filteredFiles; // Memorizza solo i file filtrati
                displayFiles(filteredFiles);
                
                console.log(`Caricati ${filteredFiles.length} file rilevanti su ${files.length} totali`);
                
                // Aspetta il tempo minimo prima di nascondere l'animazione
                await minLoadingTime;
                
                // Nascondi l'animazione di caricamento
                loadingAnimation.style.display = 'none';
            } catch (error) {
                console.error('Errore nel caricamento dei file speaker:', error);
                alert('Errore nel caricamento dei file. Riprova più tardi.');
                // Nascondi l'animazione di caricamento in caso di errore
                document.getElementById('loading-animation').style.display = 'none';
            }
        }

        function initializeFilters() {
            // Aggiungi event listener per i filtri di testo
            const textFilters = [
                'client-filter', 'product-kind-filter', 'brand-filter', 
                'range-filter', 'line-filter', 'model-filter', 
                'filename-filter', 'filekind-filter', 'description-filter'
            ];
            
            // Ripristina i filtri salvati
            const savedFilters = JSON.parse(localStorage.getItem('speakerFilesFilters'));
            textFilters.forEach(filterId => {
                const filterElement = document.getElementById(filterId);
                if (filterElement) {
                    // Imposta il valore salvato se presente
                    if (savedFilters && savedFilters[filterId]) {
                        filterElement.value = savedFilters[filterId];
                    }
                    // Aggiungi event listener per salvare i filtri
                    filterElement.addEventListener('input', function() {
                        applyFilters();
                        saveFilters();
                    });
                }
            });
            
            // Applica i filtri se sono stati ripristinati
            if (savedFilters) {
                // Controlla se almeno un filtro ha un valore
                const hasActiveFilter = Object.values(savedFilters).some(value => value && value.trim() !== '');
                if (hasActiveFilter) {
                    // Carica automaticamente i dati se ci sono filtri attivi
                    loadSpeakerFiles().then(() => {
                        applyFilters();
                    });
                } else {
                    applyFilters();
                }
            }

            // Aggiungi event listener per le checkbox di visibilità colonne
            const columnCheckboxes = document.querySelectorAll('.column-visibility input[type="checkbox"]');
            columnCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', toggleColumnVisibility);
            });

            // Aggiungi event listener per il raggruppamento tramite click sull'intestazione della colonna
            enableColumnSorting();
            
            // Aggiungi event listener per i pulsanti "View Selected" e "Download Selected"
            const viewSelectedButton = document.getElementById('view-selected');
            if (viewSelectedButton) {
                viewSelectedButton.addEventListener('click', viewSelectedFiles);
            }
            
            const downloadSelectedButton = document.getElementById('download-selected');
            if (downloadSelectedButton) {
                downloadSelectedButton.addEventListener('click', downloadSelectedFiles);
            }
        }

        // Funzione per salvare i filtri nel localStorage
        function saveFilters() {
            const filters = {
                'client-filter': document.getElementById('client-filter')?.value || '',
                'product-kind-filter': document.getElementById('product-kind-filter')?.value || '',
                'brand-filter': document.getElementById('brand-filter')?.value || '',
                'range-filter': document.getElementById('range-filter')?.value || '',
                'line-filter': document.getElementById('line-filter')?.value || '',
                'model-filter': document.getElementById('model-filter')?.value || '',
                'filename-filter': document.getElementById('filename-filter')?.value || '',
                'filekind-filter': document.getElementById('filekind-filter')?.value || '',
                'description-filter': document.getElementById('description-filter')?.value || ''
            };
            localStorage.setItem('speakerFilesFilters', JSON.stringify(filters));
        }
        
        // Funzione per visualizzare i file selezionati
        function viewSelectedFiles() {
            const selectedRows = document.querySelectorAll('#speaker-files-table tbody tr.selected');
            if (selectedRows.length === 0) {
                alert('No files selected. Please select at least one file.');
                return;
            }
            
            const graphWindowName = 'graphViewer';
            let graphWindow = window.open('', graphWindowName);
            
            if (!graphWindow || graphWindow.closed || !graphWindow.location || !graphWindow.location.href.includes('graph-viewer.html')) {
                graphWindow = window.open('graph-viewer.html', graphWindowName);
                graphWindow.onload = () => sendSelectedFilesToGraphWindow(graphWindow);
            } else {
                graphWindow.focus();
                sendSelectedFilesToGraphWindow(graphWindow);
            }
        }
        
        // Funzione per scaricare i file selezionati
        function downloadSelectedFiles() {
            const selectedRows = document.querySelectorAll('#speaker-files-table tbody tr.selected');
            if (selectedRows.length === 0) {
                alert('No files selected. Please select at least one file.');
                return;
            }
            
            selectedRows.forEach(row => {
                const fileId = row.dataset.fileId;
                window.open(`/api/files/${fileId}/download`, '_blank');
            });
        }

        function applyFilters() {
                const filters = {
                client: document.getElementById('client-filter')?.value.toLowerCase() || '',
                productKind: document.getElementById('product-kind-filter')?.value.toLowerCase() || '',
                brand: document.getElementById('brand-filter')?.value.toLowerCase() || '',
                range: document.getElementById('range-filter')?.value.toLowerCase() || '',
                line: document.getElementById('line-filter')?.value.toLowerCase() || '',
                model: document.getElementById('model-filter')?.value.toLowerCase() || '',
                filename: document.getElementById('filename-filter')?.value.toLowerCase() || '',
                filekind: document.getElementById('filekind-filter')?.value.toLowerCase() || '',
                description: document.getElementById('description-filter')?.value.toLowerCase() || ''
            };

            // Controlla se almeno un filtro è impostato
            const isFilterSet = filters.client || filters.productKind || filters.brand || filters.range || filters.line || filters.model || filters.filename || filters.filekind;

            if (isFilterSet && allFiles.length === 0) {
                // Carica i dati solo se un filtro è impostato e i dati non sono ancora stati caricati
                loadSpeakerFiles();
            } else {
                const filteredFiles = allFiles.filter(file => {
                    return (
                        (!filters.client || (file.client || '').toLowerCase().includes(filters.client)) &&
                        (!filters.productKind || (file.productKind || '').toLowerCase().includes(filters.productKind)) &&
                        (!filters.brand || (file.brand || '').toLowerCase().includes(filters.brand)) &&
                        (!filters.range || (file.range || '').toLowerCase().includes(filters.range)) &&
                        (!filters.line || (file.line || '').toLowerCase().includes(filters.line)) &&
                        (!filters.model || (file.modelNumber || '').toLowerCase().includes(filters.model)) &&
                        (!filters.filename || (file.filename || '').toLowerCase().includes(filters.filename)) &&
                        (!filters.filekind || determineFileType(file.filename, file.content).toLowerCase().includes(filters.filekind)) &&
                        (!filters.description || (file.description || '').toLowerCase().includes(filters.description))
                    );
                });

                displayFiles(filteredFiles);
                applyLastSorting(); // Applica l'ultimo ordinamento salvato dopo il filtraggio
            }
        }

        function toggleColumnVisibility() {
            const table = document.getElementById('speaker-files-table');
            const columnCheckboxes = document.querySelectorAll('.column-visibility input[type="checkbox"]');
            
            columnCheckboxes.forEach(checkbox => {
                const columnIndex = parseInt(checkbox.getAttribute('data-column'));
                const isVisible = checkbox.checked;
                
                // Nascondi/mostra header
                const headerCell = table.querySelector(`thead tr th:nth-child(${columnIndex + 1})`);
                if (headerCell) {
                    headerCell.style.display = isVisible ? '' : 'none';
                }
                
                // Nascondi/mostra celle delle righe
                const bodyCells = table.querySelectorAll(`tbody tr td:nth-child(${columnIndex + 1})`);
                bodyCells.forEach(cell => {
                    cell.style.display = isVisible ? '' : 'none';
                });
            });
        }

        function displayFiles(files) {
            const tbody = document.querySelector('#speaker-files-table tbody');
            tbody.innerHTML = '';
            const filterMessage = document.getElementById('filter-message');
            if (files.length === 0) {
                filterMessage.style.display = 'block';
            } else {
                filterMessage.style.display = 'none';
            }

            files.forEach(file => {
                const row = document.createElement('tr');
                row.dataset.fileId = file.id;
                row.style.cursor = 'pointer';
                
                row.addEventListener('click', function(e) {
                    // Evita di selezionare la riga se si clicca su un pulsante di azione
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'I') {
                        this.classList.toggle('selected');
                    }
                });
                
                // Colonna Client
                const clientCell = document.createElement('td');
                clientCell.textContent = file.client || '-';
                row.appendChild(clientCell);
                
                // Colonna Product Kind
                const productKindCell = document.createElement('td');
                productKindCell.textContent = file.productKind || '-';
                row.appendChild(productKindCell);
                
                // Colonna Brand
                const brandCell = document.createElement('td');
                brandCell.textContent = file.brand || '-';
                row.appendChild(brandCell);
                
                // Colonna Range
                const rangeCell = document.createElement('td');
                rangeCell.textContent = file.range || '-';
                row.appendChild(rangeCell);
                
                // Colonna Line
                const lineCell = document.createElement('td');
                lineCell.textContent = file.line || '-';
                row.appendChild(lineCell);
                
                // Colonna Model N - con link al progetto
                const modelCell = document.createElement('td');
                if (file.modelNumber && file.modelNumber !== '-' && file.project_id) {
                    // Crea un link cliccabile per il model number usando il project_id
                    const modelLink = document.createElement('a');
                    modelLink.href = `project-details.html?id=${encodeURIComponent(file.project_id)}`;
                    modelLink.textContent = file.modelNumber;
                    modelLink.style.color = '#007bff';
                    modelLink.style.textDecoration = 'underline';
                    modelLink.style.cursor = 'pointer';
                    modelLink.title = `Visualizza dettagli progetto per ${file.modelNumber}`;
                    
                    // Previeni la selezione della riga quando si clicca sul link
                    modelLink.addEventListener('click', function(e) {
                        e.stopPropagation();
                    });
                    
                    modelCell.appendChild(modelLink);
                } else {
                    modelCell.textContent = file.modelNumber || '-';
                }
                row.appendChild(modelCell);
                
                // Colonna File Name
                const nameCell = document.createElement('td');
                nameCell.textContent = file.filename;
                row.appendChild(nameCell);
                
                // Colonna Description
                const descriptionCell = document.createElement('td');
                descriptionCell.textContent = file.description || '-';
                row.appendChild(descriptionCell);
                
                // Colonna File Kind
                const fileKindCell = document.createElement('td');
                fileKindCell.textContent = determineFileType(file.filename, file.content);
                row.appendChild(fileKindCell);
                
                // Colonna Actions rimossa
                tbody.appendChild(row);
            });

            restoreColumnWidths();
        }

        function determineFileType(filename, content) {
            if (filename.toLowerCase().endsWith('.txt')) {
                if (content) {
                    // Verifica se contiene parametri TS
                    if (checkForTSParameters(content)) {
                        return 'TS Parameters';
                    }
                    
                    // Verifica se contiene dati di risposta in frequenza o impedenza
                    const { dataType } = analyzeFileContent(content);
                    if (dataType === 'db') {
                        return 'Frequency Response';
                    } else if (dataType === 'ohm') {
                        return 'Impedance';
                    }
                }
                return 'Text File (content not loaded)';
            }
            return 'Other';
        }

        function checkForTSParameters(content) {
            const keywords = ["Fs", "Re", "Sd", "Qms", "Qes", "Qts", "Cms", "Mms", "Rms", "Bl", "dBspl", "VAS", "Zmin", "L1kHz", "L10kHz"];
            let count = 0;
            keywords.forEach(kw => {
                if (content.toLowerCase().includes(kw.toLowerCase())) {
                    count++;
                }
            });
            return count >= 3;
        }

        function analyzeFileContent(content) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let dataType = 'unknown';
            let startIndex = 0;

            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const lineForCheck = lines[i].toLowerCase();
                if (lineForCheck.includes('db')) {
                    dataType = 'db';
                } else if (lineForCheck.includes('ohm') || lineForCheck.includes('impedance')) {
                    dataType = 'ohm';
                }

                if (lineForCheck.includes('[') || lineForCheck.includes(']') || 
                    lineForCheck.includes('freq') || 
                    lineForCheck.includes('phase') || 
                    lineForCheck.includes('hz') ||
                    dataType !== 'unknown' ||
                    /^[a-zA-Z]/.test(lines[i])) {
                    startIndex = i + 1;
                } else {
                    const parts = lines[i].split(/[\s,;\t]+/).filter(p => p.length > 0);
                    const numericParts = parts.filter(p => !isNaN(parseFloat(p)) && isFinite(parseFloat(p)));
                    if (numericParts.length >= 2 && numericParts.length === parts.length) {
                        if (startIndex <= i) {
                            startIndex = i;
                        }
                        break;
                    } else {
                        startIndex = i + 1;
                    }
                }
            }
            return { dataType, startIndex };
        }

        function extractDataPoints(content, startIndex) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const points = [];
            
            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i];
                if (!line || line.startsWith('#') || line.startsWith('//')) {
                    continue;
                }
                const parts = line.split(/[\s,;\t]+/).filter(p => p.length > 0);
                if (parts.length >= 2) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    if (!isNaN(x) && isFinite(x) && !isNaN(y) && isFinite(y)) {
                        points.push({ x, y });
                    }
                }
            }
            return points;
        }

        async function viewFile(file) {
            // Controlla se ci sono righe selezionate
            const selectedRows = document.querySelectorAll('#speaker-files-table tbody tr.selected');
            if (selectedRows.length > 0) {
                const graphWindowName = 'graphViewer';
                let graphWindow = window.open('', graphWindowName);
                
                if (!graphWindow || graphWindow.closed || !graphWindow.location || !graphWindow.location.href.includes('graph-viewer.html')) {
                    graphWindow = window.open('graph-viewer.html', graphWindowName);
                    graphWindow.onload = () => sendSelectedFilesToGraphWindow(graphWindow);
                } else {
                    graphWindow.focus();
                    sendSelectedFilesToGraphWindow(graphWindow);
                }
            } else {
                // Se non ci sono righe selezionate, visualizza solo il file corrente
                await loadFileContent(file.id);
                openSingleFile(file);
            }
        }

        async function sendSelectedFilesToGraphWindow(targetWindow) {
            const selectedRows = document.querySelectorAll('#speaker-files-table tbody tr.selected');
            for (const row of selectedRows) {
                const fileId = row.dataset.fileId;
                const file = allFiles.find(f => f.id == fileId);
                if (file && file.filename.toLowerCase().endsWith('.txt')) {
                    try {
                        // Assicurati che il contenuto sia caricato
                        if (!file.content) {
                            await loadFileContent(file.id);
                        }
                        const content = file.content || '';
                        const { dataType, startIndex } = analyzeFileContent(content);
                        const points = extractDataPoints(content, startIndex);
                        
                        if (points.length > 0) {
                            targetWindow.postMessage({
                                type: 'addGraph',
                                points: points,
                                filename: file.filename,
                                dataType: dataType
                            }, '*');
                        } else if (checkForTSParameters(content)) {
                            targetWindow.postMessage({
                                type: 'addFloatingText',
                                filename: file.filename,
                                content: content
                            }, '*');
                        }
                    } catch (error) {
                        console.error(`Error processing "${file.filename}" as graph:`, error);
                    }
                }
            }
        }

        async function openSingleFile(file) {
            if (file.filename.toLowerCase().endsWith('.txt')) {
                try {
                    // Assicurati che il contenuto sia caricato
                    if (!file.content) {
                        await loadFileContent(file.id);
                    }
                    const content = file.content || '';
                    const { dataType, startIndex } = analyzeFileContent(content);
                    const points = extractDataPoints(content, startIndex);
                    
                    if (points.length > 0) {
                        const graphWindowName = 'graphViewer';
                        let graphWindow = window.open('', graphWindowName);
                        const sendDataToGraphWindow = (targetWindow) => {
                            targetWindow.postMessage({
                                type: 'addGraph',
                                points: points,
                                filename: file.filename,
                                dataType: dataType
                            }, '*');
                        };
                        if (!graphWindow || graphWindow.closed || !graphWindow.location || !graphWindow.location.href.includes('graph-viewer.html')) {
                            graphWindow = window.open('graph-viewer.html', graphWindowName);
                            graphWindow.onload = () => sendDataToGraphWindow(graphWindow);
                        } else {
                            graphWindow.focus();
                            sendDataToGraphWindow(graphWindow);
                        }
                    } else if (checkForTSParameters(content)) {
                        const graphWindowName = 'graphViewer';
                        let graphWindow = window.open('', graphWindowName);
                        const sendFloatingToGraphWindow = (targetWindow) => {
                            targetWindow.postMessage({
                                type: 'addFloatingText',
                                filename: file.filename,
                                content: content
                            }, '*');
                        };
                        if (!graphWindow || graphWindow.closed || !graphWindow.location || !graphWindow.location.href.includes('graph-viewer.html')) {
                            graphWindow = window.open('graph-viewer.html', graphWindowName);
                            graphWindow.onload = () => sendFloatingToGraphWindow(graphWindow);
                        } else {
                            graphWindow.focus();
                            sendFloatingToGraphWindow(graphWindow);
                        }
                    } else {
                        window.open(`/api/files/${file.id}/view`, '_blank');
                    }
                } catch (error) {
                    console.error(`Error opening "${file.filename}" as graph:`, error);
                    window.open(`/api/files/${file.id}/view`, '_blank');
                }
            } else {
                window.open(`/api/files/${file.id}/view`, '_blank');
            }
        }

        function downloadFile(fileId) {
            window.location.href = `/api/files/${fileId}/download`;
        }

        // Funzione per abilitare l'ordinamento e il raggruppamento delle colonne
        function enableColumnSorting() {
            const table = document.getElementById('speaker-files-table');
            const headers = table.getElementsByTagName('th');
            let sortDirection = Array(headers.length).fill(true); // true per ascendente, false per discendente

            // Carica l'ultimo stato di ordinamento dal localStorage
            const lastSorting = JSON.parse(localStorage.getItem('lastSpeakerFilesSorting'));
            if (lastSorting) {
                sortDirection[lastSorting.columnIndex] = lastSorting.direction;
            }

            // Carica lo stato dei lucchetti salvato e le direzioni
            const savedLocks = JSON.parse(localStorage.getItem('lockedColumns'));
            const savedDirections = JSON.parse(localStorage.getItem('lockedColumnsDirection'));
            if (savedLocks) {
                lockedColumns = savedLocks;
                document.querySelectorAll('.lock-icon').forEach(icon => {
                    const colIndex = parseInt(icon.getAttribute('data-column'));
                    if (lockedColumns.includes(colIndex)) {
                        icon.classList.add('locked');
                        // Ripristina la direzione di ordinamento se salvata
                        if (savedDirections && savedDirections[colIndex] !== undefined) {
                            lockedColumnsDirection[colIndex] = savedDirections[colIndex];
                            sortDirection[colIndex] = savedDirections[colIndex];
                        }
                    }
                });
            }

            for (let i = 0; i < headers.length; i++) { // Itera su tutte le colonne
                headers[i].addEventListener('click', function() {
                    const columnIndex = i;
                    
                    // Se la colonna è bloccata, non fare nulla
                    if (lockedColumns.includes(columnIndex)) {
                        return;
                    }

                    const rows = Array.from(table.getElementsByTagName('tbody')[0].rows);
                    const isAscending = sortDirection[columnIndex];

                    // Salva l'ultimo ordinamento nel localStorage
                    localStorage.setItem('lastSpeakerFilesSorting', JSON.stringify({
                        columnIndex: columnIndex,
                        direction: !isAscending // Salva la prossima direzione
                    }));

                    // Rimuovi le classi di ordinamento da tutte le righe
                    rows.forEach(row => {
                        row.classList.remove('sorted-asc-1', 'sorted-asc-2', 'sorted-desc-1', 'sorted-desc-2');
                    });

                    // Rimuovi la classe sorted da tutti gli header
                    Array.from(headers).forEach(header => header.classList.remove('sorted'));
                    // Aggiungi la classe sorted all'header corrente
                    headers[columnIndex].classList.add('sorted');

                    // Funzione di confronto per l'ordinamento
                    const compareFn = (a, b) => {
                        // Prima verifica tutte le colonne bloccate in ordine
                        for (const lockedCol of lockedColumns.sort((a, b) => a - b)) {
                            const aLocked = a.cells[lockedCol].textContent.trim();
                            const bLocked = b.cells[lockedCol].textContent.trim();
                            const compareResult = aLocked.localeCompare(bLocked);
                            if (compareResult !== 0) {
                                // Usa la direzione salvata per questa colonna bloccata
                                const direction = lockedColumnsDirection[lockedCol];
                                return direction ? compareResult : -compareResult;
                            }
                        }
                        
                        // Se tutte le colonne bloccate sono uguali, ordina per la colonna corrente
                        // Solo se la colonna corrente non è bloccata
                        if (!lockedColumns.includes(columnIndex)) {
                            const aText = a.cells[columnIndex].textContent.trim();
                            const bText = b.cells[columnIndex].textContent.trim();
                            return isAscending ? aText.localeCompare(bText) : bText.localeCompare(aText);
                        }
                        
                        // Se la colonna corrente è bloccata, mantieni l'ordine attuale
                        return 0;
                    };

                    rows.sort(compareFn);

                    // Raggruppa le righe con lo stesso valore
                    let currentValue = '';
                    let colorGroup = 1;

                    rows.forEach(row => {
                        const cellValue = row.cells[columnIndex].textContent.trim();
                        if (cellValue !== currentValue) {
                            currentValue = cellValue;
                            colorGroup = colorGroup === 1 ? 2 : 1;
                        }
                        row.classList.add(isAscending ? `sorted-asc-${colorGroup}` : `sorted-desc-${colorGroup}`);
                    });

                    sortDirection[columnIndex] = !isAscending; // Cambia direzione di ordinamento
                    rows.forEach(row => table.getElementsByTagName('tbody')[0].appendChild(row)); // Riordina le righe
                });
            }
        }

        // Funzione per applicare l'ultimo ordinamento salvato
        function applyLastSorting() {
            const table = document.getElementById('speaker-files-table');
            const lastSorting = JSON.parse(localStorage.getItem('lastSpeakerFilesSorting'));
            if (lastSorting) {
                const headers = table.getElementsByTagName('th');
                if (headers[lastSorting.columnIndex]) {
                    // Se la direzione salvata è false (discendente), clicca due volte per ottenere l'ordine discendente
                    headers[lastSorting.columnIndex].click();
                    if (!lastSorting.direction) {
                        headers[lastSorting.columnIndex].click();
                    }
                }
            }
        }

        // Funzione per applicare l'ordinamento predefinito a Model N
        function applyDefaultSorting() {
            const table = document.getElementById('speaker-files-table');
            const lastSorting = JSON.parse(localStorage.getItem('lastSpeakerFilesSorting'));
            // Se non c'è un ordinamento salvato, imposta Model N come predefinito
            if (!lastSorting) {
                const modelNHeader = table.querySelector('th:nth-child(6)');
                if (modelNHeader) {
                    modelNHeader.click();
                    // Salva l'ordinamento predefinito nel localStorage
                    localStorage.setItem('lastSpeakerFilesSorting', JSON.stringify({
                        columnIndex: 5,
                        direction: true
                    }));
                }
            } else {
                applyLastSorting();
            }
        }

        // La funzione adjustColumnWidths non è più necessaria, il ridimensionamento manuale la sostituisce.
        
        // Funzione per caricare il contenuto di un file specifico
        async function loadFileContent(fileId) {
            try {
                const contentResponse = await fetch(`/api/files/${fileId}/content`);
                if (contentResponse.ok) {
                    const content = await contentResponse.text();
                    // Aggiorna il contenuto nel array allFiles
                    const fileIndex = allFiles.findIndex(f => f.id == fileId);
                    if (fileIndex !== -1) {
                        allFiles[fileIndex].content = content;
                    }
                    return content;
                } else {
                    throw new Error(`HTTP error! status: ${contentResponse.status}`);
                }
            } catch (err) {
                console.warn(`Impossibile caricare il contenuto del file con ID ${fileId}:`, err);
                return '';
            }
        }
    </script>
</body>
</html>
