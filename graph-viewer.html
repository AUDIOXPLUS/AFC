<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="js/vendor/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e2a3a;
            color: #ffffff;
        }
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #1e2a3a;
        }
        h1 {
            color: #ffffff;
            text-align: center;
            margin: 10px 0;
            font-size: 18px;
        }
        .toolbar {
            background-color: #2a3a4a;
            padding: 8px;
            border-bottom: 1px solid #3a4a5a;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            align-items: center;
        }
        .toolbar button {
            padding: 6px 12px;
            background-color: #4a5a6a;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            min-width: 30px;
        }
        .toolbar button:hover {
            background-color: #5a6a7a;
        }
        .toolbar .separator {
            width: 1px;
            height: 20px;
            background-color: #3a4a5a;
            margin: 0 5px;
        }
        .chart-container {
            flex: 1;
            position: relative;
            padding: 20px;
            background-color: #1e2a3a;
        }
        .controls {
            display: none; /* Nascondiamo i controlli originali */
        }
        .dataset-controls {
            position: absolute;
            top: 35px;
            left: calc(80px); /* Spostato a destra del 10% */
            background-color: rgba(42, 58, 74, 0.9);
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Aggiunta ombra per effetto flottante */
        }
        .dataset-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }
        /* Classe .dataset-color rimossa perch√© non utilizzata nel codice JavaScript */

        
        /* Stili per i controlli della toolbar */
        .toolbar label {
            color: #ffffff;
            font-size: 12px;
            margin-right: 3px;
        }
        
        .toolbar input, .toolbar select {
            padding: 4px 6px;
            background-color: #1e2a3a;
            border: 1px solid #3a4a5a;
            border-radius: 3px;
            color: #ffffff;
            font-size: 12px;
        }
        
        .color-picker {
            width: 10px;
            height: 10px;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
            outline: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            background-clip: padding-box !important;
            cursor: pointer;
            margin-right: 5px;
            /* Elimina ogni possibile bordo o contorno */
            -webkit-border-radius: 0 !important;
            -moz-border-radius: 0 !important;
            -webkit-box-shadow: none !important;
            -moz-box-shadow: none !important;
            /* Il backgroundColor viene gi√† impostato da JavaScript */
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="loader" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(30,42,58,0.8); display: flex; justify-content: center; align-items: center; z-index: 1000;">
            <div style="color: white; text-align: center;">
                <i class="fas fa-spinner fa-spin" style="font-size: 24px;"></i>
                <p>Caricamento curva in corso...</p>
            </div>
        </div>
        <h1>Frequency Response Analyzer</h1>
        
        <div class="toolbar">
            <!-- Controlli Frequenze -->
            <label>Freq Min:</label>
            <input type="number" id="freq-min" value="20" min="1" max="100000" style="width: 80px;">
            <label>Max:</label>
            <input type="number" id="freq-max" value="20000" min="1" max="100000" style="width: 80px;">
            
            <div class="separator"></div>
            
            <!-- Controlli dB -->
            <label>dB Min:</label>
            <input type="number" id="db-min" value="20" min="-100" max="200" style="width: 60px;">
            <label>Max:</label>
            <input type="number" id="db-max" value="120" min="-100" max="200" style="width: 60px;">
            <label>Scala:</label>
            <select id="db-scale" style="width: 60px;">
                <option value="1">1dB</option>
                <option value="3">3dB</option>
                <option value="5" selected>5dB</option>
                <option value="10">10dB</option>
            </select>
            
            <div class="separator"></div>
            
            <label><input type="checkbox" id="grid-toggle" checked> Grid</label>
            
            <div class="separator"></div>
            
            <!-- Controlli Ohm -->
            <label>Ohm Min:</label>
            <input type="number" id="ohm-min" value="0" min="0" max="1000" style="width: 60px;">
            <label>Max:</label>
            <input type="number" id="ohm-max" value="100" min="0" max="1000" style="width: 60px;">
            
            <div class="separator"></div>
            
            <button id="export-btn" title="Export">üíæ</button>
            <button id="clear-btn" title="Clear">üóëÔ∏è</button>
        </div>

        <div class="chart-container">
            <canvas id="graph-canvas"></canvas>
            
            <div class="dataset-controls">
                <h4 style="margin: 0 0 10px 0; font-size: 14px;">Datasets</h4>
                <div id="dataset-list"></div>
            </div>
            

        </div>
    </div>



    <script>
        // Array per memorizzare i dataset
        let datasets = [];
        let chart = null;
        let nextColorIndex = 0;
        let chartReady = false; // Flag per indicare se initChart √® stato completato
        let selectedDatasetIndex = -1; // Indice del dataset selezionato
        let frozenTooltip = null; // Tooltip congelato
        const colors = [
            'rgb(75, 192, 192)',
            'rgb(255, 99, 132)',
            'rgb(54, 162, 235)',
            'rgb(255, 159, 64)',
            'rgb(153, 102, 255)',
            'rgb(201, 203, 207)',
            'rgb(255, 205, 86)'
        ];

        // Highlight della frequenza sull'asse x con colore della curva
        function highlightFrequency(freq, color) {
            if (!chart) return;
            
            // Rimuovi eventuali highlight precedenti
            const xScale = chart.scales.x;
            if (xScale._highlightLine) {
                xScale.ctx.clearRect(
                    xScale._highlightLine.x - 1, 
                    xScale.top, 
                    2, 
                    xScale.bottom - xScale.top
                );
            }
            
            // Disegna la nuova linea di highlight
            const xPos = xScale.getPixelForValue(freq);
            xScale.ctx.strokeStyle = color || 'rgba(255, 255, 255, 0.7)';
            xScale.ctx.lineWidth = 2;
            xScale.ctx.beginPath();
            xScale.ctx.moveTo(xPos, xScale.top);
            xScale.ctx.lineTo(xPos, xScale.bottom);
            xScale.ctx.stroke();
            
            // Salva la posizione per poterla rimuovere dopo
            xScale._highlightLine = {x: xPos, color: color};
        }

        // Mostra il valore dB persistente della curva selezionata
        function showFrozenValue(freq, value, color, yAxisID) {
            const container = document.querySelector('.chart-container');
            
            // Rimuovi eventuali valori precedenti
            const existing = document.getElementById('frozen-value');
            if (existing) existing.remove();
            
            // Determina l'unit√† di misura
            const unit = yAxisID === 'yOhm' ? 'Œ©' : 'dB';
            const yAxis = chart.scales[yAxisID]; // Ottieni l'asse Y corretto
            
            // Crea il nuovo elemento
            const div = document.createElement('div');
            div.id = 'frozen-value';
            div.style.position = 'absolute';
            div.style.left = chart.scales.x.getPixelForValue(freq) + 'px';
            div.style.top = yAxis.getPixelForValue(value) + 'px'; // Usa l'asse Y corretto
            div.style.transform = 'translate(-50%, -50%)';
            div.style.backgroundColor = 'rgba(42, 58, 74, 0.9)';
            div.style.color = color || '#ffffff';
            div.style.padding = '2px 6px';
            div.style.borderRadius = '3px';
            div.style.border = `1px solid ${color || '#ffffff'}`;
            div.style.fontSize = '12px';
            div.textContent = `${value.toFixed(1)} ${unit}`;
            
            container.appendChild(div);
        }

        // Definizione del posizionatore personalizzato per il tooltip
        // Questo posizioner√† il tooltip in corrispondenza della posizione Y del mouse
        Chart.Tooltip.positioners.mouseYPosition = function(elements, eventPosition) {
            // elements: array degli elementi attivi del tooltip
            // eventPosition: {x, y} coordinate dell'evento mouse relative al canvas
            return {
                x: eventPosition.x,
                y: eventPosition.y
            };
        };

        // Gestore ottimizzato per il click sul canvas
        function handleCanvasClick(event) {
            if (!chart || chart.data.datasets.length <= 1) return;
            
            const points = chart.getElementsAtEventForMode(
                event, 
                'nearest', 
                {intersect: false}, 
                true
            );
            
            if (points.length > 0) {
                const point = points[0];
                selectedDatasetIndex = point.datasetIndex;
                
                // Aggiorna lo stile delle curve
                chart.data.datasets.forEach((dataset, i) => {
                    dataset.borderWidth = (i === selectedDatasetIndex) ? 4 : 2;
                    dataset.borderDash = [];
                });
                
                // Congela il tooltip e mostra valore persistente
                const freq = point.element.$context.parsed.x;
                const yValue = point.element.$context.parsed.y; // Questo √® il valore sull'asse Y associato al dataset
                const datasetIndex = point.datasetIndex;
                const yAxisID = chart.data.datasets[datasetIndex].yAxisID;
                const color = chart.data.datasets[datasetIndex].borderColor;

                frozenTooltip = {
                    freq: freq,
                    value: yValue, // Usiamo un nome generico 'value'
                    yAxisID: yAxisID, // Memorizziamo l'ID dell'asse
                    color: color,
                    datasetIndex: datasetIndex,
                    clickedPointIndex: point.index
                };
                
                // Highlight frequenza sull'asse x con colore della curva
                highlightFrequency(freq, color);
                // Mostra valore persistente
                showFrozenValue(freq, yValue, color, yAxisID);
                
                requestAnimationFrame(() => chart.update());
            }
        }

        // Inizializza il grafico
        function initChart() {
            if (chartReady) return; // Esegui solo una volta
            
            // Aggiungi gestore eventi click sul canvas (ottimizzato)
            const canvas = document.getElementById('graph-canvas');
            canvas.addEventListener('click', handleCanvasClick);
            canvas.style.willChange = 'contents'; // Ottimizza le animazioni

            const ctx = canvas.getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets // Chart.js user√† i dati presenti in questo array al momento della creazione
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    backgroundColor: '#1e2a3a',
                    scales: {
                        x: {
                            type: 'logarithmic',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Frequency (Hz)',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#ffffff',
                                callback: function(value) {
                                    if (value >= 1000) {
                                        return (value / 1000) + 'k';
                                    }
                                    return value;
                                }
                            },
                            grid: {
                                color: '#3a4a5a',
                                lineWidth: 1
                            },
                            min: 20,
                            max: 20000
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'dBSPL',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#ffffff'
                            },
                            grid: {
                                color: '#3a4a5a',
                                lineWidth: 1
                            },
                            min: 20,
                            max: 120
                        },
                        yOhm: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Ohm',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#ffffff'
                            },
                            grid: {
                                display: false
                            },
                            min: 0,
                            max: 100
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                    tooltip: {
                        position: 'mouseYPosition', // Usa il posizionatore personalizzato
                        // yAlign: 'top', // Non pi√π necessario con il posizionatore custom
                        // caretPadding: 100, // Non pi√π necessario con il posizionatore custom
                        backgroundColor: 'rgba(42, 58, 74, 0.9)',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        borderColor: '#ffffff',
                        borderWidth: 1,
                        filter: function(tooltipItem) {
                            // Escludi completamente la curva selezionata dal tooltip
                            if (frozenTooltip && tooltipItem.datasetIndex === frozenTooltip.datasetIndex) {
                                return false;
                            }
                            return true;
                        },
                        callbacks: {
                            title: function(context) {
                                // Mostra sempre la frequenza
                                return `${context[0].parsed.x.toFixed(1)} Hz`;
                            },
                            label: function(context) {
                                const currentDataset = context.dataset;
                                const currentYAxisID = currentDataset.yAxisID;
                                const currentUnit = currentYAxisID === 'yOhm' ? 'Œ©' : 'dB';
                                
                                // Se una curva √® selezionata (frozenTooltip esiste)
                                if (frozenTooltip) {
                                    // Calcola il delta solo se l'unit√† di misura √® la stessa
                                    // Altrimenti, mostra il valore assoluto della curva corrente
                                    if (currentYAxisID === frozenTooltip.yAxisID) {
                                        const delta = context.parsed.y - frozenTooltip.value;
                                        const sign = delta >= 0 ? '+' : '';
                                        return `${sign}${delta.toFixed(1)} ${currentUnit}`;
                                    } else {
                                        return `${context.parsed.y.toFixed(1)} ${currentUnit}`;
                                    }
                                }
                                // Altrimenti mostra il valore assoluto
                                return `${context.parsed.y.toFixed(1)} ${currentUnit}`;
                            },
                            labelColor: function(context) {
                                // Restituisce il colore per l'indicatore nel tooltip
                                return {
                                    borderColor: context.dataset.borderColor,
                                    backgroundColor: context.dataset.borderColor,
                                    borderWidth: 0,
                                    borderRadius: 0,
                                    boxWidth: 8,
                                    boxHeight: 8
                                };
                            }
                        },
                        external: function(context) {
                            // Resetta il tooltip congelato quando il mouse esce dal grafico
                            if (context.tooltip.opacity === 0 && frozenTooltip) {
                                frozenTooltip = null;
                                selectedDatasetIndex = -1;
                                
                                // Ripristina lo stile delle curve
                                chart.data.datasets.forEach(dataset => {
                                    dataset.borderWidth = 2;
                                });
                                
                                // Rimuovi highlight frequenza
                                const xScale = chart.scales.x;
                                if (xScale._highlightLine) {
                                    xScale.ctx.clearRect(
                                        xScale._highlightLine.x - 1, 
                                        xScale.top, 
                                        2, 
                                        xScale.bottom - xScale.top
                                    );
                                    delete xScale._highlightLine;
                                }
                                
                                // Rimuovi valore persistente
                                const frozenValue = document.getElementById('frozen-value');
                                if (frozenValue) frozenValue.remove();
                                
                                chart.update();
                            }
                        }
                        }
                    },
                    elements: {
                        point: {
                            radius: 0,
                            hoverRadius: 4
                        },
                        line: {
                            tension: 0.1
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
            chartReady = true; // Il grafico √® ora inizializzato

            // Se dei dati sono stati aggiunti a 'datasets' prima che initChart completasse,
            // assicurati che il grafico li mostri e la lista sia aggiornata.
            if (datasets.length > 0) {
                chart.update(); // Assicura che i dati pre-esistenti siano renderizzati
                updateDatasetList();
            }

            // Invia messaggio che il viewer √® pronto
            if (window.opener && typeof window.opener.postMessage === 'function') {
                console.log('Graph viewer sending graphViewerReady (initChart)');
                window.opener.postMessage({ type: 'graphViewerReady', windowName: window.name || 'graphViewer' }, '*');
            }
        }

        // Aggiungi un nuovo dataset al grafico
        function addDataset(points, filename) {
            const color = colors[nextColorIndex % colors.length];
            nextColorIndex++;
            
            // Analizza il contenuto per determinare se √® un file di impedenza
            let isImpedance = false;
            if (points.length > 0 && points[0].content) {
                const content = points[0].content.toLowerCase();
                isImpedance = content.includes('ohm');
            }
            
            const newDataset = {
                label: filename,
                data: points,
                backgroundColor: 'transparent',
                borderColor: color,
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                yAxisID: isImpedance ? 'yOhm' : 'y',
                pointRadius: function(context) {
                    // context contiene datasetIndex e dataIndex (l'indice del punto)
                    // Mostra un pallino se questo √® il punto cliccato e congelato
                    if (frozenTooltip &&
                        context.datasetIndex === frozenTooltip.datasetIndex &&
                        context.dataIndex === frozenTooltip.clickedPointIndex) {
                        return 5; // Raggio del punto cliccato e "congelato"
                    }
                    return 0; // Normalmente i punti non sono visibili
                },
                pointHoverRadius: function(context) {
                    // Mantieni il raggio del punto cliccato o usa il raggio standard per l'hover
                    if (frozenTooltip &&
                        context.datasetIndex === frozenTooltip.datasetIndex &&
                        context.dataIndex === frozenTooltip.clickedPointIndex) {
                        return 5; // Mantiene lo stesso raggio se √® il punto cliccato
                    }
                    return 4; // Raggio standard per l'hover sugli altri punti
                }
            };
            
            datasets.push(newDataset); // Aggiungi sempre i dati all'array globale
            
            if (chartReady) { // Se il grafico √® gi√† inizializzato e pronto
                chart.data.datasets = datasets; // Assegna l'array aggiornato
                
                // Ottimizzazione: aggiorna solo se necessario
                requestAnimationFrame(() => {
                    chart.update(); // Aggiorna il grafico
                    updateDatasetList(); // Aggiorna la UI della lista dataset
                });
            }
            // Se chartReady √® false, initChart() (chiamato da DOMContentLoaded)
            // prender√† i dati da 'datasets' e gestir√† l'aggiornamento.
        }

        // Aggiorna la lista dei dataset nel pannello di controllo (ottimizzata)
        function updateDatasetList() {
            const list = document.getElementById('dataset-list');
            
            // Usa DocumentFragment per minimizzare i reflow
            const fragment = document.createDocumentFragment();
            
            // Crea una mappa dei dataset esistenti per evitare ricostruzioni non necessarie
            const existingItems = Array.from(list.children).reduce((acc, child) => {
                const label = child.querySelector('span').textContent;
                acc[label] = child;
                return acc;
            }, {});
            
            datasets.forEach((dataset, index) => {
                let item = existingItems[dataset.label];
                
                if (!item) {
                    // Crea nuovo elemento solo se non esiste gi√†
                    item = document.createElement('div');
                    item.className = 'dataset-item';
                    item.style.marginBottom = '8px';
                    
                    // Color picker
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.className = 'color-picker';
                    colorInput.value = rgbToHex(dataset.borderColor);
                    colorInput.style.backgroundColor = colorInput.value;
                    colorInput.addEventListener('change', function() {
                        datasets[index].borderColor = this.value;
                        this.style.backgroundColor = this.value;
                        if (chart) chart.update();
                    });
                    
                    const label = document.createElement('span');
                    label.textContent = dataset.label;
                    label.style.flex = '1';
                    label.style.marginLeft = '5px';
                    
                    const toggleBtn = document.createElement('button');
                    toggleBtn.innerHTML = '<i class="fas fa-eye-slash"></i>';
                    toggleBtn.title = 'Toggle visibility';
                    toggleBtn.style.fontSize = '10px';
                    toggleBtn.style.padding = '2px 6px';
                    toggleBtn.style.marginLeft = '5px';
                    toggleBtn.onclick = () => toggleDataset(index);
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                    removeBtn.title = 'Remove dataset';
                    removeBtn.style.fontSize = '10px';
                    removeBtn.style.padding = '2px 6px';
                    removeBtn.style.marginLeft = '3px';
                    removeBtn.onclick = () => removeDataset(index);
                    
                    item.appendChild(colorInput);
                    item.appendChild(label);
                    item.appendChild(toggleBtn);
                    item.appendChild(removeBtn);
                } else {
                    // Aggiorna solo il color picker se l'elemento esiste gi√†
                    const colorInput = item.querySelector('input[type="color"]');
                    colorInput.value = rgbToHex(dataset.borderColor);
                    colorInput.style.backgroundColor = colorInput.value;
                }
                
                fragment.appendChild(item);
            });
            
            // Sostituisci tutto in un'unica operazione
            list.innerHTML = '';
            list.appendChild(fragment);
        }

        // Mostra/nascondi un dataset
        function toggleDataset(index) {
            const meta = chart.getDatasetMeta(index);
            meta.hidden = !meta.hidden;
            chart.update();
        }

        // Rimuovi un dataset
        function removeDataset(index) {
            datasets.splice(index, 1);
            chart.data.datasets = datasets;
            chart.update();
            updateDatasetList();
        }

        // Esporta il grafico come immagine
        document.getElementById('export-btn').addEventListener('click', function() {
            // Salva le opzioni originali
            const originalXTicksColor = chart.options.scales.x.ticks.color;
            const originalYTicksColor = chart.options.scales.y.ticks.color;
            const originalXTitleColor = chart.options.scales.x.title.color;
            const originalYTitleColor = chart.options.scales.y.title.color;
            
            // Imposta i colori a nero per l'esportazione
            chart.options.scales.x.ticks.color = '#000000';
            chart.options.scales.y.ticks.color = '#000000';
            chart.options.scales.x.title.color = '#000000';
            chart.options.scales.y.title.color = '#000000';
            chart.update();
            
            // Crea il link di download
            const link = document.createElement('a');
            link.download = 'graph.png';
            link.href = document.getElementById('graph-canvas').toDataURL('image/png');
            
            // Ripristina i colori originali dopo un breve delay
            setTimeout(() => {
                chart.options.scales.x.ticks.color = originalXTicksColor;
                chart.options.scales.y.ticks.color = originalYTicksColor;
                chart.options.scales.x.title.color = originalXTitleColor;
                chart.options.scales.y.title.color = originalYTitleColor;
                chart.update();
            }, 100);
            
            link.click();
        });

        // Pulisci tutti i grafici
        document.getElementById('clear-btn').addEventListener('click', function() {
            datasets = [];
            if (chart) {
                chart.data.datasets = [];
                chart.update();
            }
            updateDatasetList();
        });

        // Converte RGB in formato esadecimale
        function rgbToHex(rgb) {
            // Estrae i valori RGB dalla stringa
            const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            return rgb; // Se √® gi√† in formato hex
        }

        // Funzione per applicare le impostazioni istantaneamente
        function applySettings() {
            if (!chart) return;
            
            // Applica le impostazioni degli assi
            const freqMin = parseFloat(document.getElementById('freq-min').value);
            const freqMax = parseFloat(document.getElementById('freq-max').value);
            const dbMin = parseFloat(document.getElementById('db-min').value);
            const dbMax = parseFloat(document.getElementById('db-max').value);
            const dbScale = parseFloat(document.getElementById('db-scale').value);
            
            // Valida i valori
            if (freqMin >= freqMax || dbMin >= dbMax) {
                return; // Non applicare se i valori non sono validi
            }
            
            // Aggiorna le scale del grafico
            chart.options.scales.x.min = freqMin;
            chart.options.scales.x.max = freqMax;
            chart.options.scales.y.min = dbMin;
            chart.options.scales.y.max = dbMax;
            
            // Configura la scala dB
            chart.options.scales.y.ticks.stepSize = dbScale;
            
            // Applica le impostazioni per l'asse Ohm
            const ohmMin = parseFloat(document.getElementById('ohm-min').value);
            const ohmMax = parseFloat(document.getElementById('ohm-max').value);
            
            if (chart.options.scales.yOhm) { // Controlla se l'asse yOhm esiste
                if (!isNaN(ohmMin) && !isNaN(ohmMax) && ohmMin < ohmMax) {
                    chart.options.scales.yOhm.min = ohmMin;
                    chart.options.scales.yOhm.max = ohmMax;
                }
            }
            
            // Aggiorna il grafico
            chart.update();
        }

        // Event listeners per applicare i cambiamenti istantaneamente
        document.getElementById('freq-min').addEventListener('input', applySettings);
        document.getElementById('freq-max').addEventListener('input', applySettings);
        document.getElementById('db-min').addEventListener('input', applySettings);
        document.getElementById('db-max').addEventListener('input', applySettings);
        document.getElementById('db-scale').addEventListener('change', applySettings);
        
        // Aggiungi event listeners per i controlli Ohm
        document.getElementById('ohm-min').addEventListener('input', applySettings);
        document.getElementById('ohm-max').addEventListener('input', applySettings);

        // Controlli checkbox
        document.getElementById('grid-toggle').addEventListener('change', function() {
            if (chart) {
                const showGrid = this.checked;
                chart.options.scales.x.grid.display = showGrid;
                chart.options.scales.y.grid.display = showGrid;
                chart.update();
            }
        });





        // Gestione ottimizzata dei messaggi dalla finestra principale
        function handleAppMessages(event) {
            if (!event.data) return;

            if (event.data.type === 'addGraph') {
                // Mostra il loader
                document.getElementById('loader').style.display = 'flex';
                
                // Usa requestAnimationFrame per priorit√† alta
                requestAnimationFrame(() => {
                    try {
                        addDataset(event.data.points, event.data.filename);
                        // Nascondi il loader dopo un breve delay per evitare flickering
                        setTimeout(() => {
                            document.getElementById('loader').style.display = 'none';
                        }, 300);
                    } catch (error) {
                        console.error('Error adding dataset:', error);
                        document.getElementById('loader').style.display = 'none';
                    }
                });
            } else if (event.data.type === 'areYouReady') {
                // Rispondi se il grafico √® pronto
                // Assicurati che il messaggio sia per questa finestra specifica se targetWindowName √® fornito
                if (event.data.targetWindowName && (window.name !== event.data.targetWindowName)) {
                    return; 
                }
                if (chartReady && window.opener && typeof window.opener.postMessage === 'function') {
                    console.log('Graph viewer responding to areYouReady with graphViewerReady');
                    window.opener.postMessage({ type: 'graphViewerReady', windowName: window.name || 'graphViewer' }, '*');
                }
            }
        }

        // Aggiungi listener ottimizzato
        window.addEventListener('message', handleAppMessages, { passive: true });

        // Inizializza il grafico al caricamento della pagina
        window.addEventListener('DOMContentLoaded', () => {
            initChart();
            // Nascondi il loader dopo l'inizializzazione, ma assicurati che sia visibile se i dati arrivano subito
            // Il loader viene nascosto anche in addDataset dopo il caricamento dei dati.
            // Se non ci sono dati iniziali, nascondilo qui.
            if (datasets.length === 0) {
                 document.getElementById('loader').style.display = 'none';
            }
        });
    </script>
</body>
</html>
