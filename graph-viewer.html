<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="js/vendor/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e2a3a;
            color: #ffffff;
        }
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #1e2a3a;
        }
        h1 {
            color: #ffffff;
            text-align: center;
            margin: 10px 0;
            font-size: 18px;
        }
        .toolbar {
            background-color: #2a3a4a;
            padding: 8px;
            border-bottom: 1px solid #3a4a5a;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            align-items: center;
        }
        .toolbar button {
            padding: 6px 12px;
            background-color: #4a5a6a;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            min-width: 30px;
        }
        .toolbar button:hover {
            background-color: #5a6a7a;
        }
        .toolbar .separator {
            width: 1px;
            height: 20px;
            background-color: #3a4a5a;
            margin: 0 5px;
        }
        .chart-container {
            flex: 1;
            position: relative;
            padding: 20px;
            background-color: #1e2a3a;
        }
        .controls {
            display: none; /* Nascondiamo i controlli originali */
        }
        .dataset-controls {
            position: absolute;
            top: 35px;
            left: calc(80px); /* Spostato a destra del 10% */
            background-color: rgba(42, 58, 74, 0.9);
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Aggiunta ombra per effetto flottante */
        }
        .dataset-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s ease-in-out;
        }
        .dataset-value {
            width: 70px; /* Larghezza fissa per l'allineamento */
            text-align: right;
            margin-right: 8px;
            font-family: monospace;
            font-size: 13px;
            color: #c0d0e0; /* Colore per il valore */
        }
        .dataset-separator {
            border: 0;
            border-top: 1px solid #3a4a5a;
            margin: 5px 0;
        }
        /* Classe .dataset-color rimossa perch√© non utilizzata nel codice JavaScript */

        
        /* Stili per i controlli della toolbar */
        .toolbar label {
            color: #ffffff;
            font-size: 12px;
            margin-right: 3px;
        }
        
        .toolbar input, .toolbar select {
            padding: 4px 6px;
            background-color: #1e2a3a;
            border: 1px solid #3a4a5a;
            border-radius: 3px;
            color: #ffffff;
            font-size: 12px;
        }
        
        .color-picker {
            width: 10px;
            height: 10px;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
            outline: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            background-clip: padding-box !important;
            cursor: pointer;
            margin-right: 5px;
            /* Elimina ogni possibile bordo o contorno */
            -webkit-border-radius: 0 !important;
            -moz-border-radius: 0 !important;
            -webkit-box-shadow: none !important;
            -moz-box-shadow: none !important;
            /* Il backgroundColor viene gi√† impostato da JavaScript */
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="loader" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(30,42,58,0.8); display: flex; justify-content: center; align-items: center; z-index: 1000;">
            <div style="color: white; text-align: center;">
                <i class="fas fa-spinner fa-spin" style="font-size: 24px;"></i>
                <p>Caricamento curva in corso...</p>
            </div>
        </div>
        <h1>Frequency Response Analyzer</h1>
        
        <div class="toolbar">
            <!-- Controlli Frequenze -->
            <label>Freq Min:</label>
            <input type="number" id="freq-min" value="20" min="1" max="100000" style="width: 80px;">
            <label>Max:</label>
            <input type="number" id="freq-max" value="20000" min="1" max="100000" style="width: 80px;">
            
            <div class="separator"></div>
            
            <!-- Controlli dB -->
            <label>dB Min:</label>
            <input type="number" id="db-min" value="20" min="-100" max="200" style="width: 60px;">
            <label>Max:</label>
            <input type="number" id="db-max" value="120" min="-100" max="200" style="width: 60px;">
            <label>Scala:</label>
            <select id="db-scale" style="width: 60px;">
                <option value="1">1dB</option>
                <option value="3">3dB</option>
                <option value="5" selected>5dB</option>
                <option value="10">10dB</option>
            </select>
            
            <div class="separator"></div>
            
            <!-- Controlli Ohm -->
            <label>Ohm Min:</label>
            <input type="number" id="ohm-min" value="0" min="0" max="1000" style="width: 60px;">
            <label>Max:</label>
            <input type="number" id="ohm-max" value="100" min="0" max="1000" style="width: 60px;">

            <div class="separator"></div>
            
            <label><input type="checkbox" id="grid-toggle" checked> Grid</label>
            
            <div class="separator"></div>
                        
            <button id="export-btn" title="Export">üíæ</button>
            <button id="clear-btn" title="Clear">üóëÔ∏è</button>
        </div>

        <div class="chart-container">
            <canvas id="graph-canvas"></canvas>
            
            <div class="dataset-controls">
                <h4 style="margin: 0 0 10px 0; font-size: 14px;">Datasets</h4>
                <div id="dataset-list"></div>
            </div>
        </div>
    </div>

    <script>
        // Array per memorizzare i dataset
        let datasets = [];
        let originalDatasets = []; // Array per conservare i dati originali
        let chart = null;
        let nextColorIndex = 0;
        let chartReady = false; // Flag per indicare se initChart √® stato completato
        let selectedDatasetIndex = null; // Indice del dataset selezionato (null se nessuno √® selezionato)
        let lastMouseEvent = null; // Memorizza l'ultimo evento del mouse per il re-sorting
        const colors = [
            'rgb(75, 192, 192)',
            'rgb(255, 99, 132)',
            'rgb(54, 162, 235)',
            'rgb(255, 159, 64)',
            'rgb(153, 102, 255)',
            'rgb(201, 203, 207)',
            'rgb(255, 205, 86)'
        ];


        Chart.Tooltip.positioners.mouseYPosition = function(elements, eventPosition) {
            return {
                x: eventPosition.x,
                y: eventPosition.y
            };
        };

        /**
         * Interpola il valore Y per una data ascissa X su una scala logaritmica.
         * @param {Array} data - Array di punti {x, y}.
         * @param {number} x - Il valore x per cui interpolare y.
         * @returns {number|null} - Il valore y interpolato o null se non trovabile.
         */
        function getInterpolatedY(data, x) {
            for (let i = 0; i < data.length - 1; i++) {
                const p1 = data[i];
                const p2 = data[i+1];
                if (p1.x <= x && p2.x >= x) {
                    const logX = Math.log(x);
                    const logX1 = Math.log(p1.x);
                    const logX2 = Math.log(p2.x);
                    if (logX2 === logX1) return p1.y; // Evita divisione per zero
                    return p1.y + (p2.y - p1.y) * (logX - logX1) / (logX2 - logX1);
                }
            }
            return null; // X √® fuori dal range del dataset
        }


        function handleCanvasClick(event) {
            if (!chart) return;
            const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: false }, true);

            if (points.length > 0) {
                const clickedIndex = points[0].datasetIndex;
                
                // Se si clicca sulla curva gi√† selezionata, deselezionala.
                if (selectedDatasetIndex === clickedIndex) {
                    selectedDatasetIndex = null;
                } else {
                    selectedDatasetIndex = clickedIndex;
                }

                // Forza un aggiornamento dell'hover per ricalcolare i valori della legenda
                if (lastMouseEvent) {
                    chart.options.onHover(lastMouseEvent, [], chart);
                }
                chart.update('none'); // Aggiorna il grafico per mostrare il bordo pi√π spesso
            
            } else {
                // Se si clicca fuori, deseleziona tutto
                if (selectedDatasetIndex !== null) {
                    selectedDatasetIndex = null;
                    if (lastMouseEvent) {
                        chart.options.onHover(lastMouseEvent, [], chart);
                    }
                    chart.update('none');
                }
            }
        }

        function updateGridVisibility() {
            if (!chart) return;

            const showGrid = document.getElementById('grid-toggle').checked;
            chart.options.scales.x.grid.display = showGrid;

            const isDbAxisVisible = chart.options.scales.y.display;
            const isOhmAxisVisible = chart.options.scales.yOhm.display;

            if (isDbAxisVisible) {
                chart.options.scales.y.grid.display = showGrid;
            }

            // Mostra la griglia per l'asse Ohm solo se l'asse dB non √® visibile per evitare sovrapposizioni.
            if (isOhmAxisVisible) {
                chart.options.scales.yOhm.grid.display = !isDbAxisVisible && showGrid;
            }
        }

        // Nuova funzione per aggiornare la visibilit√† degli assi e dei controlli
        function updateAxesAndControlsVisibility() {
            if (!chart) return;

            const freqControls = [
                document.getElementById('freq-min'), document.getElementById('freq-max'),
                document.querySelector('label[for="freq-min"]'), document.querySelector('label[for="freq-max"]')
            ].filter(el => el); // Rimuovi eventuali elementi null se i selettori falliscono
            
            const dbControls = [
                document.getElementById('db-min'), document.getElementById('db-max'), document.getElementById('db-scale'),
                document.querySelector('label[for="db-min"]'), document.querySelector('label[for="db-max"]'), document.querySelector('label[for="db-scale"]')
            ].filter(el => el);

            const ohmControls = [
                document.getElementById('ohm-min'), document.getElementById('ohm-max'),
                document.querySelector('label[for="ohm-min"]'), document.querySelector('label[for="ohm-max"]')
            ].filter(el => el);

            let showDb = false;
            let showOhm = false;

            if (datasets.length > 0) {
                const typesInData = new Set(datasets.map(ds => ds.yAxisID));
                if (typesInData.has('y')) showDb = true;
                if (typesInData.has('yOhm')) showOhm = true;
            } else {
                // Se non ci sono dataset, potremmo voler mostrare i controlli dB di default
                showDb = true; 
                showOhm = false;
            }

            chart.options.scales.y.display = showDb;
            chart.options.scales.yOhm.display = showOhm;

            updateGridVisibility(); // Aggiorna la visibilit√† della griglia in base agli assi visibili

            // I controlli di frequenza sono sempre visibili
            freqControls.forEach(el => el.style.display = ''); 

            dbControls.forEach(el => el.style.display = showDb ? '' : 'none');
            ohmControls.forEach(el => el.style.display = showOhm ? '' : 'none');
            
            const separators = Array.from(document.querySelectorAll('.toolbar .separator'));
            
            // Logica di visibilit√† per i separatori (semplificata)
            // Separatore 0 (dopo Freq): visibile se dB o Ohm sono visibili
            if (separators[0]) separators[0].style.display = (showDb || showOhm) ? '' : 'none';
            // Separatore 1 (dopo dB): visibile se dB √® visibile E (Ohm √® visibile OPPURE Grid √® visibile)
            if (separators[1]) separators[1].style.display = showDb && (showOhm || document.getElementById('grid-toggle').checked) ? '' : 'none';
             // Separatore 2 (dopo Ohm): visibile se Ohm √® visibile E Grid √® visibile
            if (separators[2]) separators[2].style.display = showOhm && document.getElementById('grid-toggle').checked ? '' : 'none';
            // Separatore 3 (dopo Grid): sempre visibile se Grid √® visibile (per separare dai bottoni)
            // Questa logica potrebbe necessitare di aggiustamenti in base al layout esatto e a quanti separatori ci sono.
            // Per ora, la logica sopra gestisce i primi tre. L'ultimo separatore prima dei bottoni
            // dovrebbe essere visibile se l'ultimo gruppo di controlli prima di esso √® visibile.
            const gridToggleLabel = document.querySelector('label[for="grid-toggle"]');
            if (separators[3] && gridToggleLabel) { // Assumendo che il 4¬∞ separatore sia dopo Grid
                 separators[3].style.display = gridToggleLabel.style.display !== 'none' ? '' : 'none';
            }


            const h1 = document.querySelector('h1');
            if (showOhm && !showDb) {
                h1.textContent = 'Impedance Analyzer';
            } else if (showDb && !showOhm) {
                h1.textContent = 'Frequency Response Analyzer';
            } else if (showDb && showOhm) {
                h1.textContent = 'Frequency & Impedance Analyzer';
            } else {
                 // Se non ci sono dati o solo dati di tipo 'unknown' che mappano a 'y' ma senza 'db' esplicito
                h1.textContent = 'Graph Viewer';
            }
        }


        function initChart() {
            if (chartReady) return;
            
            const canvas = document.getElementById('graph-canvas');
            canvas.addEventListener('click', handleCanvasClick);
            canvas.style.willChange = 'contents';

            canvas.addEventListener('mousemove', (e) => {
                lastMouseEvent = e; // Aggiorna l'ultima posizione del mouse
            });

            // Aggiunto per pulire i valori e ripristinare l'ordine quando il mouse esce dal grafico
            canvas.addEventListener('mouseout', () => {
                if (!chart) return;
                lastMouseEvent = null; // Resetta l'evento del mouse
                const list = document.getElementById('dataset-list');
                const items = Array.from(list.children);
                
                // Pulisce i valori e lo stile di hover
                items.forEach(item => {
                    const valueSpan = item.querySelector('.dataset-value');
                    if (valueSpan) valueSpan.textContent = '';
                    const labelSpan = item.querySelector('.dataset-label');
                    item.style.backgroundColor = 'transparent';
                    if (labelSpan) labelSpan.style.fontWeight = 'normal';
                });

                // Riordina gli elementi in base all'indice originale
                items.sort((a, b) => {
                    const indexA = parseInt(a.dataset.originalIndex, 10);
                    const indexB = parseInt(b.dataset.originalIndex, 10);
                    return indexA - indexB;
                });

                // Rimuove eventuali separatori e ripopola la lista
                list.innerHTML = '';
                items.forEach(item => list.appendChild(item));

                // Ripristina lo spessore dei bordi
                chart.data.datasets.forEach((dataset, index) => {
                    dataset.borderWidth = (index === selectedDatasetIndex) ? 4 : 2;
                });
                chart.update('none');
            });

            const ctx = canvas.getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    backgroundColor: '#1e2a3a',
                    onHover: (event, activeElements, chart) => {
                        const canvas = chart.canvas;
                        const mouseX = event.x;
                        
                        if (mouseX > chart.chartArea.left && mouseX < chart.chartArea.right) {
                            const xValue = chart.scales.x.getValueForPixel(mouseX);
                            const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, false);
                            let hoveredDatasetIndex = -1;
                            if (points.length > 0) {
                                hoveredDatasetIndex = points[0].datasetIndex;
                            }

                            // Ottieni il valore Y di riferimento se una curva √® selezionata
                            let referenceY = null;
                            if (selectedDatasetIndex !== null && originalDatasets[selectedDatasetIndex]) {
                                const referenceData = originalDatasets[selectedDatasetIndex].data;
                                referenceY = getInterpolatedY(referenceData, xValue);
                            }

                            const calculatedValues = originalDatasets.map((dataset, index) => {
                                const meta = chart.getDatasetMeta(index);
                                const data = dataset.data; // Usa sempre i dati originali
                                let yValue = null;
                                if (!meta.hidden) {
                                    yValue = getInterpolatedY(data, xValue);
                                }
                                return { index, yValue, yAxisID: dataset.yAxisID, hidden: meta.hidden };
                            });

                            const sortRule = (a, b) => {
                                if (a.hidden && !b.hidden) return 1;
                                if (!a.hidden && b.hidden) return -1;
                                if (a.hidden && b.hidden) return 0;
                                if (a.yValue === null && b.yValue !== null) return 1;
                                if (a.yValue !== null && b.yValue === null) return -1;
                                if (a.yValue === null && b.yValue === null) return 0;
                                return b.yValue - a.yValue;
                            };

                            const dbValues = calculatedValues.filter(v => v.yAxisID === 'y').sort(sortRule);
                            const ohmValues = calculatedValues.filter(v => v.yAxisID === 'yOhm').sort(sortRule);

                            const list = document.getElementById('dataset-list');
                            const fragment = document.createDocumentFragment();
                            const allItems = Array.from(list.children);

                            const appendGroup = (values, unit) => {
                                values.forEach(({ index, yValue }) => {
                                    const item = allItems.find(child => parseInt(child.dataset.originalIndex) === index);
                                    if (item) {
                                        const valueSpan = item.querySelector('.dataset-value');
                                        valueSpan.style.color = '#c0d0e0'; // Resetta il colore di default

                                        if (yValue !== null) {
                                            // Se una curva di riferimento √® selezionata, gestisci la visualizzazione delta
                                            if (selectedDatasetIndex !== null && referenceY !== null && unit === 'dB') {
                                                if (index === selectedDatasetIndex) {
                                                    // La curva di riferimento mostra il suo valore assoluto
                                                    valueSpan.textContent = `${yValue.toFixed(1)} ${unit}`;
                                                } else {
                                                    // Le altre curve mostrano il delta
                                                    const displayValue = yValue - referenceY;
                                                    valueSpan.textContent = `${displayValue > 0 ? '+' : ''}${displayValue.toFixed(1)} dB`;
                                                    // Applica i colori per il delta
                                                    if (displayValue > 0) {
                                                        valueSpan.style.color = 'lightgreen';
                                                    } else if (displayValue < 0) {
                                                        valueSpan.style.color = 'salmon';
                                                    }
                                                }
                                            } else {
                                                // Modalit√† normale: mostra il valore assoluto
                                                valueSpan.textContent = `${yValue.toFixed(1)} ${unit}`;
                                            }
                                        } else {
                                            valueSpan.textContent = '';
                                        }
                                        fragment.appendChild(item);
                                    }
                                });
                            };

                            appendGroup(dbValues, 'dB');
                            if (dbValues.some(v => !v.hidden) && ohmValues.some(v => !v.hidden)) {
                                const separator = document.createElement('hr');
                                separator.className = 'dataset-separator';
                                fragment.appendChild(separator);
                            }
                            appendGroup(ohmValues, 'Œ©');
                            
                            list.innerHTML = '';
                            list.appendChild(fragment);

                            // Gestione evidenziazione
                            chart.data.datasets.forEach((dataset, index) => {
                                const isSelected = (index === selectedDatasetIndex);
                                const isHovered = (index === hoveredDatasetIndex);
                                dataset.borderWidth = (isSelected || isHovered) ? 4 : 2;
                                
                                const legendItem = Array.from(list.children).find(child => child.dataset && parseInt(child.dataset.originalIndex) === index);
                                if (legendItem) {
                                    const labelSpan = legendItem.querySelector('.dataset-label');
                                    // Applica lo stile di sfondo per la curva selezionata
                                    if (isSelected) {
                                        legendItem.style.backgroundColor = 'rgba(75, 192, 192, 0.2)'; // Colore di highlight per la selezione
                                        if (labelSpan) labelSpan.style.fontWeight = 'bold';
                                    } else if (isHovered) {
                                        legendItem.style.backgroundColor = '#4a5a6a'; // Colore per l'hover
                                        if (labelSpan) labelSpan.style.fontWeight = 'bold';
                                    } else {
                                        legendItem.style.backgroundColor = 'transparent';
                                        if (labelSpan) labelSpan.style.fontWeight = 'normal';
                                    }
                                }
                            });
                        }
                        
                        chart.update('none');
                    },
                    scales: {
                        x: {
                            type: 'logarithmic', position: 'bottom',
                            title: { display: true, text: 'Frequency (Hz)', color: '#ffffff' },
                            ticks: { color: '#ffffff', callback: function(value) { return value >= 1000 ? (value / 1000) + 'k' : value; }},
                            grid: { color: '#3a4a5a', lineWidth: 1 },
                            min: 20, max: 20000
                        },
                        y: { // Asse per dBSPL
                            type: 'linear', position: 'left', display: true, // Inizialmente visibile
                            title: { display: true, text: 'dBSPL', color: '#ffffff' },
                            ticks: { color: '#ffffff', stepSize: 5 },
                            grid: { color: '#3a4a5a', lineWidth: 1 },
                            min: 20, max: 120
                        },
                        yOhm: { // Asse per Ohm
                            type: 'linear', position: 'right', display: false, // Inizialmente nascosto
                            title: { display: true, text: 'Ohm (Œ©)', color: '#ffffff' },
                            ticks: { color: '#ffffff' },
                            grid: { color: '#3a4a5a', lineWidth: 1 }, // La visibilit√† della griglia Ohm √® ora gestita dinamicamente
                            min: 0, max: 100
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: false, // Disabilita completamente il tooltip di Chart.js
                            position: 'mouseYPosition',
                            external: function(context) {
                                // Questo spazio pu√≤ essere usato per un tooltip custom in futuro, se necessario.
                            }
                        }
                    },
                    elements: { point: { radius: 0, hoverRadius: 4 }, line: { tension: 0.1 }},
                    interaction: { intersect: false, mode: 'index' }
                }
            });
            chartReady = true;
            updateAxesAndControlsVisibility(); // Chiamata iniziale

            if (datasets.length > 0) {
                chart.update();
                updateDatasetList();
            }
            if (window.opener && typeof window.opener.postMessage === 'function') {
                console.log('Graph viewer sending graphViewerReady (initChart)');
                window.opener.postMessage({ type: 'graphViewerReady', windowName: window.name || 'graphViewer' }, '*');
            }
        }

        // Modificata per accettare dataType
        function addDataset(points, filename, dataType) { 
            const color = colors[nextColorIndex % colors.length];
            nextColorIndex++;
            
            let yAxisIDToUse = 'y'; // Default a 'y' (dBSPL)
            if (dataType === 'ohm') {
                yAxisIDToUse = 'yOhm';
            } else if (dataType === 'db') {
                yAxisIDToUse = 'y';
            }
            // Se dataType √® 'unknown', user√† 'y'

            console.log(`[Graph Viewer] Aggiunta curva: ${filename}, Tipo dati: ${dataType}, Asse Y: ${yAxisIDToUse}`);

            const newDataset = {
                label: filename,
                data: points,
                backgroundColor: 'transparent',
                borderColor: color,
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                yAxisID: yAxisIDToUse,
                pointRadius: 0,
                pointHoverRadius: 4
            };
            
            // Aggiunge il dataset sia alla versione di lavoro che a quella originale
            datasets.push(newDataset);
            originalDatasets.push(JSON.parse(JSON.stringify(newDataset))); // Deep copy per i dati originali
            
            if (chartReady) {
                chart.data.datasets = datasets;
                requestAnimationFrame(() => {
                    updateAxesAndControlsVisibility(); // Aggiorna visibilit√† prima di chart.update()
                    chart.update();
                    updateDatasetList();
                });
            }
        }

        function updateDatasetList() {
            const list = document.getElementById('dataset-list');
            list.innerHTML = ''; // Pulisce la lista per ricrearla
            const fragment = document.createDocumentFragment();
            
            datasets.forEach((dataset, index) => {
                const item = document.createElement('div');
                item.className = 'dataset-item';
                item.dataset.originalIndex = index; // Aggiungo l'indice per un facile recupero
                
                // Span per il valore (es. 94.1 dB)
                const valueSpan = document.createElement('span');
                valueSpan.className = 'dataset-value';
                
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.className = 'color-picker';
                colorInput.value = rgbToHex(dataset.borderColor);
                colorInput.style.backgroundColor = colorInput.value;
                colorInput.addEventListener('input', function() {
                    datasets[index].borderColor = this.value;
                    this.style.backgroundColor = this.value;
                    if (chart) chart.update();
                });
                
                const label = document.createElement('span');
                label.className = 'dataset-label'; // Aggiunta classe per selezione
                label.textContent = dataset.label;
                label.style.flex = '1';
                label.style.marginLeft = '5px';
                
                const toggleBtn = document.createElement('button');
                toggleBtn.innerHTML = '<i class="fas fa-eye-slash"></i>';
                toggleBtn.title = 'Toggle visibility';
                toggleBtn.style.fontSize = '10px';
                toggleBtn.style.padding = '2px 6px';
                toggleBtn.style.marginLeft = '5px';
                toggleBtn.onclick = () => toggleDataset(index);
                
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                removeBtn.title = 'Remove dataset';
                removeBtn.style.fontSize = '10px';
                removeBtn.style.padding = '2px 6px';
                removeBtn.style.marginLeft = '3px';
                removeBtn.onclick = () => removeDataset(index);
                
                item.appendChild(valueSpan);
                item.appendChild(colorInput);
                item.appendChild(label);
                item.appendChild(toggleBtn);
                item.appendChild(removeBtn);
                
                fragment.appendChild(item);
            });
            
            list.appendChild(fragment);
        }

        function toggleDataset(index) {
            const meta = chart.getDatasetMeta(index);
            meta.hidden = !meta.hidden;
            
            // Trova il bottone corretto usando l'indice originale, anche dopo il riordinamento
            const allItems = document.getElementById('dataset-list').children;
            let toggleBtn = null;
            for(let item of allItems) {
                if (item.dataset && parseInt(item.dataset.originalIndex) === index) {
                    toggleBtn = item.querySelector('button[title="Toggle visibility"]');
                    break;
                }
            }

            if (toggleBtn) {
                if (meta.hidden) {
                    toggleBtn.style.color = 'red';
                } else {
                    toggleBtn.style.color = '';
                }
            }
            
            chart.update('none'); // Usiamo 'none' per evitare animazioni indesiderate

            // Forza il riordinamento della lista se il mouse √® ancora sul grafico
            if (lastMouseEvent) {
                chart.options.onHover(lastMouseEvent, [], chart);
            }
        }

        function removeDataset(index) {
            datasets.splice(index, 1);
            if (chart) { // Verifica se chart esiste
                chart.data.datasets = datasets; // Assegna l'array modificato
                chart.update();
            }
            updateDatasetList();
            updateAxesAndControlsVisibility(); // Aggiorna la UI dopo la rimozione
        }

        document.getElementById('export-btn').addEventListener('click', function() {
            if (!chart) return;
            const canvas = chart.canvas;
            const ctx = canvas.getContext('2d');

            // Salva colori e stati originali
            // const originalChartBackgroundColor = chart.options.backgroundColor; // Rimosso, gestiremo lo sfondo manualmente per l'export
            const originalXTicksColor = chart.options.scales.x.ticks.color;
            const originalYTicksColor = chart.options.scales.y.ticks.color;
            const originalYOhmsTicksColor = chart.options.scales.yOhm ? chart.options.scales.yOhm.ticks.color : null;
            const originalXTitleColor = chart.options.scales.x.title.color;
            const originalYTitleColor = chart.options.scales.y.title.color;
            const originalYOhmsTitleColor = chart.options.scales.yOhm ? chart.options.scales.yOhm.title.color : null;
            const originalXGridColor = chart.options.scales.x.grid.color;
            const originalYGridColor = chart.options.scales.y.grid.color;
            const originalYOhmsGridDisplay = (chart.options.scales.yOhm && chart.options.scales.yOhm.grid) ? chart.options.scales.yOhm.grid.display : null;
            const originalYOhmsGridColor = (chart.options.scales.yOhm && chart.options.scales.yOhm.grid) ? chart.options.scales.yOhm.grid.color : null;
            
            const originalLegendDisplay = chart.options.plugins.legend.display;
            const originalLegendPosition = chart.options.plugins.legend.position;
            const originalLegendLabelsColor = chart.options.plugins.legend.labels.color;

            // Imposta i colori e le opzioni per l'esportazione
            // chart.options.backgroundColor = 'white'; // Rimosso, lo sfondo bianco verr√† disegnato manualmente
            chart.options.scales.x.ticks.color = '#000000';
            chart.options.scales.y.ticks.color = '#000000';
            if (chart.options.scales.yOhm) chart.options.scales.yOhm.ticks.color = '#000000';
            chart.options.scales.x.title.color = '#000000';
            chart.options.scales.y.title.color = '#000000';
            if (chart.options.scales.yOhm) chart.options.scales.yOhm.title.color = '#000000';
            chart.options.scales.x.grid.color = '#cccccc';
            chart.options.scales.y.grid.color = '#cccccc';
            if (chart.options.scales.yOhm && chart.options.scales.yOhm.grid) {
                if (chart.options.scales.yOhm.display) {
                    chart.options.scales.yOhm.grid.display = true;
                }
                chart.options.scales.yOhm.grid.color = '#cccccc';
            }

            // Configura e mostra la legenda per l'esportazione
            chart.options.plugins.legend.display = true;
            chart.options.plugins.legend.position = 'top'; // Posizione della legenda
            chart.options.plugins.legend.labels.color = '#000000'; // Colore del testo della legenda
            chart.options.plugins.legend.labels.usePointStyle = false; // Forza l'uso di rettangoli pieni invece di stili dei punti
            chart.options.plugins.legend.labels.boxWidth = 12; // Larghezza del box colorato
            chart.options.plugins.legend.labels.padding = 10; // Spaziatura


            chart.update('none'); // Aggiorna il grafico per applicare tutte le modifiche, inclusa la legenda

            // Disegna esplicitamente lo sfondo bianco DOPO l'aggiornamento del grafico e PRIMA di toDataURL
            ctx.save();
            ctx.globalCompositeOperation = 'destination-over'; // Disegna sotto il contenuto esistente
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            const link = document.createElement('a');
            link.download = 'graph.jpg'; // Nome file JPG
            link.href = canvas.toDataURL('image/jpeg', 1.0); // Esporta come JPG con qualit√† 1.0

            // Ripristina i colori e gli stati originali
            setTimeout(() => {
                // chart.options.backgroundColor = originalChartBackgroundColor; // Rimosso
                chart.options.scales.x.ticks.color = originalXTicksColor;
                chart.options.scales.y.ticks.color = originalYTicksColor;
                if (chart.options.scales.yOhm && originalYOhmsTicksColor !== null) chart.options.scales.yOhm.ticks.color = originalYOhmsTicksColor;
                chart.options.scales.x.title.color = originalXTitleColor;
                chart.options.scales.y.title.color = originalYTitleColor;
                if (chart.options.scales.yOhm && originalYOhmsTitleColor !== null) chart.options.scales.yOhm.title.color = originalYOhmsTitleColor;
                chart.options.scales.x.grid.color = originalXGridColor;
                chart.options.scales.y.grid.color = originalYGridColor;
                if (chart.options.scales.yOhm && chart.options.scales.yOhm.grid) {
                    if (originalYOhmsGridDisplay !== null) chart.options.scales.yOhm.grid.display = originalYOhmsGridDisplay;
                    if (originalYOhmsGridColor !== null) chart.options.scales.yOhm.grid.color = originalYOhmsGridColor;
                }

                chart.options.plugins.legend.display = originalLegendDisplay;
                chart.options.plugins.legend.position = originalLegendPosition;
                chart.options.plugins.legend.labels.color = originalLegendLabelsColor;
                // Ripristina anche usePointStyle se era stato salvato uno stato specifico, altrimenti Chart.js user√† il suo default.
                // Per sicurezza, se si vuole essere certi di ripristinare il comportamento di default di Chart.js per usePointStyle,
                // si potrebbe salvare chart.options.plugins.legend.labels.usePointStyle originale.
                // Se non era definito, Chart.js ha un suo default (spesso false per le linee).
                // Per ora, non lo ripristiniamo esplicitamente assumendo che il default di Chart.js sia OK per la visualizzazione normale.
                // Se necessario, aggiungere: chart.options.plugins.legend.labels.usePointStyle = originalUsePointStyle; (dopo averlo salvato)
                
                chart.update('none'); // Aggiorna per tornare allo stato originale
            }, 100);
            link.click();
        });

        document.getElementById('clear-btn').addEventListener('click', function() {
            datasets = [];
            if (chart) {
                chart.data.datasets = [];
                chart.update();
            }
            updateDatasetList();
            updateAxesAndControlsVisibility(); // Aggiorna la visibilit√† dopo aver pulito
        });

        function rgbToHex(rgb) {
            if (typeof rgb !== 'string') return '#000000'; // Fallback per input non validi
            const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
            }
            return rgb; 
        }

        function applySettings() {
            if (!chart) return;
            
            const freqMin = parseFloat(document.getElementById('freq-min').value);
            const freqMax = parseFloat(document.getElementById('freq-max').value);
            const dbMin = parseFloat(document.getElementById('db-min').value);
            const dbMax = parseFloat(document.getElementById('db-max').value);
            const dbScale = parseFloat(document.getElementById('db-scale').value);
            
            if (freqMin < freqMax) {
                 chart.options.scales.x.min = freqMin;
                 chart.options.scales.x.max = freqMax;
            }
            if (dbMin < dbMax) {
                chart.options.scales.y.min = dbMin;
                chart.options.scales.y.max = dbMax;
                chart.options.scales.y.ticks.stepSize = dbScale;
            }
            
            const ohmMin = parseFloat(document.getElementById('ohm-min').value);
            const ohmMax = parseFloat(document.getElementById('ohm-max').value);
            
            if (chart.options.scales.yOhm && ohmMin < ohmMax) {
                chart.options.scales.yOhm.min = ohmMin;
                chart.options.scales.yOhm.max = ohmMax;
            }
            chart.update();
        }

        ['freq-min', 'freq-max', 'db-min', 'db-max', 'ohm-min', 'ohm-max'].forEach(id => {
            document.getElementById(id).addEventListener('input', applySettings);
        });
        document.getElementById('db-scale').addEventListener('change', applySettings);

        document.getElementById('grid-toggle').addEventListener('change', function() {
            if (chart) {
                updateGridVisibility();
                chart.update();
            }
        });

        // Gestione ottimizzata dei messaggi dalla finestra principale
        function handleAppMessages(event) {
            if (!event.data) return;

            if (event.data.type === 'addGraph') {
                document.getElementById('loader').style.display = 'flex';
                requestAnimationFrame(() => {
                    try {
                        addDataset(event.data.points, event.data.filename, event.data.dataType);
                        setTimeout(() => {
                            document.getElementById('loader').style.display = 'none';
                        }, 300);
                    } catch (error) {
                        console.error('Error adding dataset:', error);
                        document.getElementById('loader').style.display = 'none';
                    }
                });
            } else if (event.data.type === 'areYouReady') {
                if (event.data.targetWindowName && (window.name !== event.data.targetWindowName)) {
                    return; 
                }
                if (chartReady && window.opener && typeof window.opener.postMessage === 'function') {
                    console.log('Graph viewer responding to areYouReady with graphViewerReady');
                    window.opener.postMessage({ type: 'graphViewerReady', windowName: window.name || 'graphViewer' }, '*');
                }
            }
        }
        window.addEventListener('message', handleAppMessages, { passive: true });

        window.addEventListener('DOMContentLoaded', () => {
            initChart();
            if (datasets.length === 0) {
                 document.getElementById('loader').style.display = 'none';
            }
            // Assicura che i label for siano corretti per i controlli della toolbar
            // Questo √® un workaround se i label non hanno l'attributo 'for'
            const toolbarLabels = document.querySelectorAll('.toolbar label');
            toolbarLabels.forEach(label => {
                const input = label.querySelector('input[type="number"], select, input[type="checkbox"]');
                if (input && input.id && !label.hasAttribute('for')) {
                    label.setAttribute('for', input.id);
                }
            });
        });
    </script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Gestione finestre floating per parametri
    function createFloatingWindow(title, content) {
        // Crea il contenitore della finestra
        const win = document.createElement('div');
        win.className = 'floating-window';
        win.style.position = 'fixed';
        win.style.top = Math.floor(Math.random() * 200 + 50) + 'px';
        win.style.left = Math.floor(Math.random() * 400 + 50) + 'px';
        win.style.width = '400px';
        win.style.background = '#fff';
        win.style.border = '2px solid #2196F3';
        win.style.borderRadius = '8px';
        win.style.boxShadow = '0 4px 16px rgba(0,0,0,0.2)';
        win.style.zIndex = 9999;
        win.style.minHeight = '60px';
        win.style.resize = 'both';
        win.style.overflow = 'auto';

        // Header con titolo e pulsanti
        const header = document.createElement('div');
        header.style.cursor = 'move';
        header.style.background = '#2196F3';
        header.style.color = '#fff';
        header.style.padding = '8px 12px';
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.borderTopLeftRadius = '8px';
        header.style.borderTopRightRadius = '8px';

        const titleSpan = document.createElement('span');
        titleSpan.textContent = title;
        header.appendChild(titleSpan);

        // Pulsanti minimizza, font +/-, chiudi
        const btns = document.createElement('div');
        btns.style.display = 'flex';
        btns.style.gap = '8px';

        // Font size controls
        const fontMinusBtn = document.createElement('button');
        fontMinusBtn.textContent = 'A-';
        fontMinusBtn.title = 'Font smaller';
        fontMinusBtn.style.background = '#fff';
        fontMinusBtn.style.color = '#2196F3';
        fontMinusBtn.style.border = 'none';
        fontMinusBtn.style.fontWeight = 'bold';
        fontMinusBtn.style.fontSize = '14px';
        fontMinusBtn.style.cursor = 'pointer';
        fontMinusBtn.style.width = '28px';
        fontMinusBtn.style.height = '28px';
        fontMinusBtn.style.borderRadius = '50%';

        const fontPlusBtn = document.createElement('button');
        fontPlusBtn.textContent = 'A+';
        fontPlusBtn.title = 'Font bigger';
        fontPlusBtn.style.background = '#fff';
        fontPlusBtn.style.color = '#2196F3';
        fontPlusBtn.style.border = 'none';
        fontPlusBtn.style.fontWeight = 'bold';
        fontPlusBtn.style.fontSize = '14px';
        fontPlusBtn.style.cursor = 'pointer';
        fontPlusBtn.style.width = '28px';
        fontPlusBtn.style.height = '28px';
        fontPlusBtn.style.borderRadius = '50%';

        const minBtn = document.createElement('button');
        minBtn.textContent = '‚Äì';
        minBtn.title = 'Minimize';
        minBtn.style.background = '#fff';
        minBtn.style.color = '#2196F3';
        minBtn.style.border = 'none';
        minBtn.style.fontWeight = 'bold';
        minBtn.style.fontSize = '18px';
        minBtn.style.cursor = 'pointer';
        minBtn.style.width = '28px';
        minBtn.style.height = '28px';
        minBtn.style.borderRadius = '50%';

        const closeBtn = document.createElement('button');
        closeBtn.textContent = '√ó';
        closeBtn.title = 'Close';
        closeBtn.style.background = '#fff';
        closeBtn.style.color = '#2196F3';
        closeBtn.style.border = 'none';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.style.fontSize = '18px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.width = '28px';
        closeBtn.style.height = '28px';
        closeBtn.style.borderRadius = '50%';

        btns.appendChild(fontMinusBtn);
        btns.appendChild(fontPlusBtn);
        btns.appendChild(minBtn);
        btns.appendChild(closeBtn);
        header.appendChild(btns);

        win.appendChild(header);

        // Corpo della finestra
        const body = document.createElement('div');
        body.className = 'floating-body';
        body.style.padding = '12px';
        body.style.overflow = 'auto';
        body.style.maxHeight = '300px';
        body.style.background = '#f9f9f9';
        body.style.fontFamily = 'monospace';
        body.style.whiteSpace = 'pre-wrap';
        body.style.color = '#222'; // testo scuro per leggibilit√†
        let fontSize = 15;
        body.style.fontSize = fontSize + 'px';
        body.textContent = content;
        win.appendChild(body);

        // Font size controls
        fontMinusBtn.addEventListener('click', function() {
            fontSize = Math.max(8, fontSize - 2);
            body.style.fontSize = fontSize + 'px';
        });
        fontPlusBtn.addEventListener('click', function() {
            fontSize = Math.min(48, fontSize + 2);
            body.style.fontSize = fontSize + 'px';
        });

        // Minimizza
        minBtn.addEventListener('click', function() {
            if (body.style.display !== 'none') {
                body.style.display = 'none';
                minBtn.textContent = '+';
            } else {
                body.style.display = '';
                minBtn.textContent = '‚Äì';
            }
        });

        // Chiudi
        closeBtn.addEventListener('click', function() {
            win.remove();
        });

        // Drag & drop
        let isDragging = false, offsetX = 0, offsetY = 0;
        header.addEventListener('mousedown', function(e) {
            isDragging = true;
            offsetX = e.clientX - win.offsetLeft;
            offsetY = e.clientY - win.offsetTop;
            document.body.style.userSelect = 'none';
        });
        document.addEventListener('mousemove', function(e) {
            if (isDragging) {
                win.style.left = (e.clientX - offsetX) + 'px';
                win.style.top = (e.clientY - offsetY) + 'px';
            }
        });
        document.addEventListener('mouseup', function() {
            isDragging = false;
            document.body.style.userSelect = '';
        });

        document.body.appendChild(win);
    }

    // Gestione postMessage
    window.addEventListener('message', function(event) {
        if (event.data && event.data.type === 'addFloatingText') {
            createFloatingWindow(event.data.filename, event.data.content);
        }
    });
});
</script>
</body>
</html>
