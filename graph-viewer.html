<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="js/vendor/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e2a3a;
            color: #ffffff;
        }
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #1e2a3a;
        }
        h1 {
            color: #ffffff;
            text-align: center;
            margin: 10px 0;
            font-size: 18px;
        }
        .toolbar {
            background-color: #2a3a4a;
            padding: 8px;
            border-bottom: 1px solid #3a4a5a;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            align-items: center;
        }
        .toolbar button {
            padding: 6px 12px;
            background-color: #4a5a6a;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            min-width: 30px;
        }
        .toolbar button:hover {
            background-color: #5a6a7a;
        }
        .toolbar .separator {
            width: 1px;
            height: 20px;
            background-color: #3a4a5a;
            margin: 0 5px;
        }
        .chart-container {
            flex: 1;
            position: relative;
            padding: 20px;
            background-color: #1e2a3a;
        }
        .controls {
            display: none; /* Nascondiamo i controlli originali */
        }
        .dataset-controls {
            position: absolute;
            top: 35px;
            left: calc(80px); /* Spostato a destra del 10% */
            background-color: rgba(42, 58, 74, 0.8); /* Pi√π opaco per leggibilit√† */
            padding: 10px;
            border-radius: 5px;
            max-width: 90vw; /* Permette espansione */
            overflow-x: auto; /* Scroll se necessario */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }
        .dataset-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s ease-in-out;
            white-space: nowrap; /* Evita a capo */
        }
        .ts-params-container {
            display: flex;
            margin-left: 10px;
            border-left: 1px solid #555;
            padding-left: 5px;
        }
        .ts-cell {
            width: 90px; /* Larghezza fissa per allineamento */
            padding: 0 5px;
            border-right: 1px solid #444;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #a0c0a0;
        }
        .dataset-value {
            width: 70px; /* Larghezza fissa per l'allineamento */
            text-align: right;
            margin-right: 8px;
            font-family: monospace;
            font-size: 13px;
            color: #c0d0e0; /* Colore per il valore */
        }
        .dataset-separator {
            border: 0;
            border-top: 1px solid #3a4a5a;
            margin: 5px 0;
        }
        /* Classe .dataset-color rimossa perch√© non utilizzata nel codice JavaScript */

        
        /* Stili per i controlli della toolbar */
        .toolbar label {
            color: #ffffff;
            font-size: 12px;
            margin-right: 3px;
        }
        
        .toolbar input, .toolbar select {
            padding: 4px 6px;
            background-color: #1e2a3a;
            border: 1px solid #3a4a5a;
            border-radius: 3px;
            color: #ffffff;
            font-size: 12px;
        }
        
        .color-picker {
            width: 10px;
            height: 10px;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
            outline: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            background-clip: padding-box !important;
            cursor: pointer;
            margin-right: 5px;
            /* Elimina ogni possibile bordo o contorno */
            -webkit-border-radius: 0 !important;
            -moz-border-radius: 0 !important;
            -webkit-box-shadow: none !important;
            -moz-box-shadow: none !important;
            /* Il backgroundColor viene gi√† impostato da JavaScript */
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="loader" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(30,42,58,0.8); display: flex; justify-content: center; align-items: center; z-index: 1000;">
            <div style="color: white; text-align: center;">
                <i class="fas fa-spinner fa-spin" style="font-size: 24px;"></i>
                <p>Caricamento curva in corso...</p>
            </div>
        </div>
        <h1>Frequency Response Analyzer</h1>
        
        <div class="toolbar">
            <!-- Controlli Frequenze -->
            <label>Freq Min:</label>
            <input type="number" id="freq-min" value="20" min="1" max="100000" style="width: 80px;">
            <label>Max:</label>
            <input type="number" id="freq-max" value="20000" min="1" max="100000" style="width: 80px;">
            
            <div class="separator"></div>
            
            <!-- Controlli dB -->
            <label>dB Min:</label>
            <input type="number" id="db-min" value="20" min="-100" max="200" style="width: 60px;">
            <label>Max:</label>
            <input type="number" id="db-max" value="120" min="-100" max="200" style="width: 60px;">
            <label>Scala:</label>
            <select id="db-scale" style="width: 60px;">
                <option value="1">1dB</option>
                <option value="3">3dB</option>
                <option value="5" selected>5dB</option>
                <option value="10">10dB</option>
            </select>
            
            <div class="separator"></div>
            
            <!-- Controlli Ohm -->
            <label>Ohm Min:</label>
            <input type="number" id="ohm-min" value="0" min="0" max="1000" style="width: 60px;">
            <label>Max:</label>
            <input type="number" id="ohm-max" value="100" min="0" max="1000" style="width: 60px;">

            <div class="separator"></div>
            
            <label><input type="checkbox" id="grid-toggle" checked> Grid</label>
            
            <div class="separator"></div>

            <button id="ts-toggle-btn" title="Toggle TS Parameters">TS</button>
            
            <div class="separator"></div>
                        
            <button id="export-btn" title="Export">üíæ</button>
            <button id="clear-btn" title="Clear">üóëÔ∏è</button>
        </div>

        <div class="chart-container">
            <canvas id="graph-canvas"></canvas>
            
            <div class="dataset-controls">
                <h4 style="margin: 0 0 10px 0; font-size: 14px;">Datasets</h4>
                <div id="dataset-list-container" style="overflow-x: auto;">
                    <table id="dataset-table" style="width: 100%; border-collapse: collapse; font-size: 12px;">
                        <thead>
                            <tr id="dataset-header-row" style="text-align: left; border-bottom: 1px solid #555;">
                                <th style="padding: 4px;">Val</th>
                                <th style="padding: 4px;">Color</th>
                                <th style="padding: 4px;">Name</th>
                                <th style="padding: 4px;">Vis</th>
                                <th style="padding: 4px;">Del</th>
                            </tr>
                        </thead>
                        <tbody id="dataset-list-body"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Array per memorizzare i dataset
        let datasets = [];
        let originalDatasets = []; // Array per conservare i dati originali
        let chart = null;
        let nextColorIndex = 0;
        let chartReady = false; // Flag per indicare se initChart √® stato completato
        let selectedDatasetIndex = null; // Indice del dataset selezionato (null se nessuno √® selezionato)
        let lastMouseEvent = null; // Memorizza l'ultimo evento del mouse per il re-sorting
        let showTSColumns = false; // Stato visualizzazione colonne TS
        const tsKeys = ["Fs", "Re", "Sd", "Qms", "Qes", "Qts", "Vas", "Mms", "Cms", "Bl", "L1kHz", "Le"];
        const colors = [
            'rgb(75, 192, 192)',
            'rgb(255, 99, 132)',
            'rgb(54, 162, 235)',
            'rgb(255, 159, 64)',
            'rgb(153, 102, 255)',
            'rgb(201, 203, 207)',
            'rgb(255, 205, 86)'
        ];


        Chart.Tooltip.positioners.mouseYPosition = function(elements, eventPosition) {
            return {
                x: eventPosition.x,
                y: eventPosition.y
            };
        };

        /**
         * Interpola il valore Y per una data ascissa X su una scala logaritmica.
         * @param {Array} data - Array di punti {x, y}.
         * @param {number} x - Il valore x per cui interpolare y.
         * @returns {number|null} - Il valore y interpolato o null se non trovabile.
         */
        function getInterpolatedY(data, x) {
            for (let i = 0; i < data.length - 1; i++) {
                const p1 = data[i];
                const p2 = data[i+1];
                if (p1.x <= x && p2.x >= x) {
                    const logX = Math.log(x);
                    const logX1 = Math.log(p1.x);
                    const logX2 = Math.log(p2.x);
                    if (logX2 === logX1) return p1.y; // Evita divisione per zero
                    return p1.y + (p2.y - p1.y) * (logX - logX1) / (logX2 - logX1);
                }
            }
            return null; // X √® fuori dal range del dataset
        }


        function handleCanvasClick(event) {
            if (!chart) return;
            const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: false }, true);

            if (points.length > 0) {
                const clickedIndex = points[0].datasetIndex;
                
                // Se si clicca sulla curva gi√† selezionata, deselezionala.
                if (selectedDatasetIndex === clickedIndex) {
                    selectedDatasetIndex = null;
                } else {
                    selectedDatasetIndex = clickedIndex;
                }

                // Forza un aggiornamento dell'hover per ricalcolare i valori della legenda
                if (lastMouseEvent) {
                    chart.options.onHover(lastMouseEvent, [], chart);
                }
                chart.update('none'); // Aggiorna il grafico per mostrare il bordo pi√π spesso
            
            } else {
                // Se si clicca fuori, deseleziona tutto
                if (selectedDatasetIndex !== null) {
                    selectedDatasetIndex = null;
                    if (lastMouseEvent) {
                        chart.options.onHover(lastMouseEvent, [], chart);
                    }
                    chart.update('none');
                }
            }
        }

        function updateGridVisibility() {
            if (!chart) return;

            const showGrid = document.getElementById('grid-toggle').checked;
            chart.options.scales.x.grid.display = showGrid;

            const isDbAxisVisible = chart.options.scales.y.display;
            const isOhmAxisVisible = chart.options.scales.yOhm.display;

            if (isDbAxisVisible) {
                chart.options.scales.y.grid.display = showGrid;
            }

            // Mostra la griglia per l'asse Ohm solo se l'asse dB non √® visibile per evitare sovrapposizioni.
            if (isOhmAxisVisible) {
                chart.options.scales.yOhm.grid.display = !isDbAxisVisible && showGrid;
            }
        }

        // Nuova funzione per aggiornare la visibilit√† degli assi e dei controlli
        function updateAxesAndControlsVisibility() {
            if (!chart) return;

            const freqControls = [
                document.getElementById('freq-min'), document.getElementById('freq-max'),
                document.querySelector('label[for="freq-min"]'), document.querySelector('label[for="freq-max"]')
            ].filter(el => el); // Rimuovi eventuali elementi null se i selettori falliscono
            
            const dbControls = [
                document.getElementById('db-min'), document.getElementById('db-max'), document.getElementById('db-scale'),
                document.querySelector('label[for="db-min"]'), document.querySelector('label[for="db-max"]'), document.querySelector('label[for="db-scale"]')
            ].filter(el => el);

            const ohmControls = [
                document.getElementById('ohm-min'), document.getElementById('ohm-max'),
                document.querySelector('label[for="ohm-min"]'), document.querySelector('label[for="ohm-max"]')
            ].filter(el => el);

            let showDb = false;
            let showOhm = false;

            if (datasets.length > 0) {
                const typesInData = new Set(datasets.map(ds => ds.yAxisID));
                if (typesInData.has('y')) showDb = true;
                if (typesInData.has('yOhm')) showOhm = true;
            } else {
                // Se non ci sono dataset, potremmo voler mostrare i controlli dB di default
                showDb = true; 
                showOhm = false;
            }

            chart.options.scales.y.display = showDb;
            chart.options.scales.yOhm.display = showOhm;

            updateGridVisibility(); // Aggiorna la visibilit√† della griglia in base agli assi visibili

            // I controlli di frequenza sono sempre visibili
            freqControls.forEach(el => el.style.display = ''); 

            dbControls.forEach(el => el.style.display = showDb ? '' : 'none');
            ohmControls.forEach(el => el.style.display = showOhm ? '' : 'none');
            
            const separators = Array.from(document.querySelectorAll('.toolbar .separator'));
            
            // Logica di visibilit√† per i separatori (semplificata)
            // Separatore 0 (dopo Freq): visibile se dB o Ohm sono visibili
            if (separators[0]) separators[0].style.display = (showDb || showOhm) ? '' : 'none';
            // Separatore 1 (dopo dB): visibile se dB √® visibile E (Ohm √® visibile OPPURE Grid √® visibile)
            if (separators[1]) separators[1].style.display = showDb && (showOhm || document.getElementById('grid-toggle').checked) ? '' : 'none';
             // Separatore 2 (dopo Ohm): visibile se Ohm √® visibile E Grid √® visibile
            if (separators[2]) separators[2].style.display = showOhm && document.getElementById('grid-toggle').checked ? '' : 'none';
            // Separatore 3 (dopo Grid): sempre visibile se Grid √® visibile (per separare dai bottoni)
            // Questa logica potrebbe necessitare di aggiustamenti in base al layout esatto e a quanti separatori ci sono.
            // Per ora, la logica sopra gestisce i primi tre. L'ultimo separatore prima dei bottoni
            // dovrebbe essere visibile se l'ultimo gruppo di controlli prima di esso √® visibile.
            const gridToggleLabel = document.querySelector('label[for="grid-toggle"]');
            if (separators[3] && gridToggleLabel) { // Assumendo che il 4¬∞ separatore sia dopo Grid
                 separators[3].style.display = gridToggleLabel.style.display !== 'none' ? '' : 'none';
            }


            const h1 = document.querySelector('h1');
            if (showOhm && !showDb) {
                h1.textContent = 'Impedance Analyzer';
            } else if (showDb && !showOhm) {
                h1.textContent = 'Frequency Response Analyzer';
            } else if (showDb && showOhm) {
                h1.textContent = 'Frequency & Impedance Analyzer';
            } else {
                 // Se non ci sono dati o solo dati di tipo 'unknown' che mappano a 'y' ma senza 'db' esplicito
                h1.textContent = 'Graph Viewer';
            }
        }


        function initChart() {
            if (chartReady) return;
            
            const canvas = document.getElementById('graph-canvas');
            // Creo una volta sola il tooltip custom per mostrare la frequenza
            const customTooltip = document.createElement('div');
            customTooltip.id = 'custom-freq-tooltip';
            customTooltip.style.position = 'fixed';
            customTooltip.style.pointerEvents = 'none';
            customTooltip.style.background = 'rgba(42, 58, 74, 0.95)';
            customTooltip.style.color = '#fff';
            customTooltip.style.padding = '4px 10px';
            customTooltip.style.borderRadius = '4px';
            customTooltip.style.fontSize = '13px';
            customTooltip.style.fontFamily = 'monospace';
            customTooltip.style.zIndex = '9999';
            customTooltip.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
            customTooltip.style.display = 'none';
            document.body.appendChild(customTooltip);
            canvas.addEventListener('click', handleCanvasClick);
            canvas.style.willChange = 'contents';

            canvas.addEventListener('mousemove', (e) => {
                lastMouseEvent = e; // Aggiorna l'ultima posizione del mouse
                // Aggiorna testo e posizione del tooltip persistente
                const freq = chart.scales.x.getValueForPixel(e.offsetX);
                customTooltip.textContent = `${freq.toFixed(1)} Hz`;
                customTooltip.style.left = (e.clientX + 16) + 'px';
                customTooltip.style.top = (e.clientY - 16) + 'px';
                customTooltip.style.display = 'block';
            });

            // Aggiunto per pulire i valori e ripristinare l'ordine quando il mouse esce dal grafico
            canvas.addEventListener('mouseout', () => {
                if (!chart) return;
                lastMouseEvent = null; // Resetta l'evento del mouse
                // Nascondi tooltip persistente
                customTooltip.style.display = 'none';
                
                const tbody = document.getElementById('dataset-list-body');
                const rows = Array.from(tbody.children);
                
                // Pulisce i valori e lo stile di hover
                rows.forEach(row => {
                    const valueCell = row.querySelector('.dataset-value-cell');
                    if (valueCell) valueCell.textContent = '';
                    row.style.backgroundColor = 'transparent';
                    row.style.fontWeight = 'normal';
                });

                // Riordina gli elementi in base all'indice originale
                rows.sort((a, b) => {
                    const indexA = parseInt(a.dataset.originalIndex, 10);
                    const indexB = parseInt(b.dataset.originalIndex, 10);
                    return indexA - indexB;
                });

                // Ripopola la lista
                tbody.innerHTML = '';
                rows.forEach(row => tbody.appendChild(row));

                // Ripristina lo spessore dei bordi
                chart.data.datasets.forEach((dataset, index) => {
                    dataset.borderWidth = (index === selectedDatasetIndex) ? 4 : 2;
                });
                chart.update('none');
            });

            const ctx = canvas.getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    backgroundColor: '#1e2a3a',
                    onHover: (event, activeElements, chart) => {
                        const canvas = chart.canvas;
                        const mouseX = event.x;
                        
                        if (mouseX > chart.chartArea.left && mouseX < chart.chartArea.right) {
                            const xValue = chart.scales.x.getValueForPixel(mouseX);
                            const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: false }, false);
                            let hoveredDatasetIndex = -1;
                            if (points.length > 0) {
                                hoveredDatasetIndex = points[0].datasetIndex;
                            }

                            // Ottieni il valore Y di riferimento se una curva √® selezionata
                            let referenceY = null;
                            if (selectedDatasetIndex !== null && originalDatasets[selectedDatasetIndex]) {
                                const referenceData = originalDatasets[selectedDatasetIndex].data;
                                referenceY = getInterpolatedY(referenceData, xValue);
                            }

                            const calculatedValues = originalDatasets.map((dataset, index) => {
                                const meta = chart.getDatasetMeta(index);
                                const data = dataset.data; // Usa sempre i dati originali
                                let yValue = null;
                                if (!meta.hidden) {
                                    yValue = getInterpolatedY(data, xValue);
                                }
                                return { index, yValue, yAxisID: dataset.yAxisID, hidden: meta.hidden };
                            });

                            const sortRule = (a, b) => {
                                if (a.hidden && !b.hidden) return 1;
                                if (!a.hidden && b.hidden) return -1;
                                if (a.hidden && b.hidden) return 0;
                                if (a.yValue === null && b.yValue !== null) return 1;
                                if (a.yValue !== null && b.yValue === null) return -1;
                                if (a.yValue === null && b.yValue === null) return 0;
                                return b.yValue - a.yValue;
                            };

                            const dbValues = calculatedValues.filter(v => v.yAxisID === 'y').sort(sortRule);
                            const ohmValues = calculatedValues.filter(v => v.yAxisID === 'yOhm').sort(sortRule);

                            const tbody = document.getElementById('dataset-list-body');
                            const fragment = document.createDocumentFragment();
                            const allRows = Array.from(tbody.children);

                            const appendGroup = (values, unit) => {
                                values.forEach(({ index, yValue }) => {
                                    const row = allRows.find(child => parseInt(child.dataset.originalIndex) === index);
                                    if (row) {
                                        const valueCell = row.querySelector('.dataset-value-cell');
                                        valueCell.style.color = '#c0d0e0'; // Resetta il colore di default

                                        if (yValue !== null) {
                                            // Se una curva di riferimento √® selezionata, gestisci la visualizzazione delta
                                            if (selectedDatasetIndex !== null && referenceY !== null && unit === 'dB') {
                                                if (index === selectedDatasetIndex) {
                                                    // La curva di riferimento mostra il suo valore assoluto
                                                    valueCell.textContent = `${yValue.toFixed(1)} ${unit}`;
                                                } else {
                                                    // Le altre curve mostrano il delta
                                                    const displayValue = yValue - referenceY;
                                                    valueCell.textContent = `${displayValue > 0 ? '+' : ''}${displayValue.toFixed(1)} dB`;
                                                    // Applica i colori per il delta
                                                    if (displayValue > 0) {
                                                        valueCell.style.color = 'lightgreen';
                                                    } else if (displayValue < 0) {
                                                        valueCell.style.color = 'salmon';
                                                    }
                                                }
                                            } else {
                                                // Modalit√† normale: mostra il valore assoluto
                                                valueCell.textContent = `${yValue.toFixed(1)} ${unit}`;
                                            }
                                        } else {
                                            valueCell.textContent = '';
                                        }
                                        fragment.appendChild(row);
                                    }
                                });
                            };

                            appendGroup(dbValues, 'dB');
                            // Separatore visivo tra gruppi non necessario in tabella, l'ordine √® sufficiente
                            appendGroup(ohmValues, 'Œ©');
                            
                            tbody.innerHTML = '';
                            tbody.appendChild(fragment);

                            // Gestione evidenziazione
                            chart.data.datasets.forEach((dataset, index) => {
                                const isSelected = (index === selectedDatasetIndex);
                                const isHovered = (index === hoveredDatasetIndex);
                                dataset.borderWidth = (isSelected || isHovered) ? 4 : 2;
                                
                                const row = Array.from(tbody.children).find(child => parseInt(child.dataset.originalIndex) === index);
                                if (row) {
                                    if (isSelected) {
                                        row.style.backgroundColor = 'rgba(75, 192, 192, 0.2)';
                                        row.style.fontWeight = 'bold';
                                    } else if (isHovered) {
                                        row.style.backgroundColor = '#4a5a6a';
                                        row.style.fontWeight = 'bold';
                                    } else {
                                        row.style.backgroundColor = 'transparent';
                                        row.style.fontWeight = 'normal';
                                    }
                                }
                            });
                        }
                        
                        chart.update('none');
                    },
                    scales: {
                        x: {
                            type: 'logarithmic', position: 'bottom',
                            title: { display: true, text: 'Frequency (Hz)', color: '#ffffff' },
                            ticks: { color: '#ffffff', callback: function(value) { return value >= 1000 ? (value / 1000) + 'k' : value; }},
                            grid: { color: '#3a4a5a', lineWidth: 1 },
                            min: 20, max: 20000
                        },
                        y: { // Asse per dBSPL
                            type: 'linear', position: 'left', display: true, // Inizialmente visibile
                            title: { display: true, text: 'dBSPL', color: '#ffffff' },
                            ticks: { color: '#ffffff', stepSize: 5 },
                            grid: { color: '#3a4a5a', lineWidth: 1 },
                            min: 20, max: 120
                        },
                        yOhm: { // Asse per Ohm
                            type: 'linear', position: 'right', display: false, // Inizialmente nascosto
                            title: { display: true, text: 'Ohm (Œ©)', color: '#ffffff' },
                            ticks: { color: '#ffffff' },
                            grid: { color: '#3a4a5a', lineWidth: 1 }, // La visibilit√† della griglia Ohm √® ora gestita dinamicamente
                            min: 0, max: 100
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: false
                        }
                    },
                    elements: { point: { radius: 0, hoverRadius: 6 }, line: { tension: 0.1 }},
                    interaction: { intersect: false, mode: 'nearest', axis: 'x' }
                }
            });
            chartReady = true;
            updateAxesAndControlsVisibility(); // Chiamata iniziale

            if (datasets.length > 0) {
                chart.update();
                updateDatasetList();
            }
            if (window.opener && typeof window.opener.postMessage === 'function') {
                console.log('Graph viewer sending graphViewerReady (initChart)');
                window.opener.postMessage({ type: 'graphViewerReady', windowName: window.name || 'graphViewer' }, '*');
            }
        }

        function parseTSContent(content) {
            const params = {};
            if (!content) return params;
            
            const lines = content.split('\n');
            
            // Mappa lowerCase key -> Chiave corretta
            // Aggiunte chiavi mancanti come Rms, dBSPL, L10kHz ecc.
            const keysMap = {
                "fs": "Fs", "re": "Re", "sd": "Sd", "qms": "Qms", "qes": "Qes", 
                "qts": "Qts", "vas": "Vas", "mms": "Mms", "cms": "Cms", "bl": "Bl", 
                "l1khz": "L1kHz", "l10khz": "L10kHz", "le": "Le", "rms": "Rms",
                "dbspl": "dBSPL", "spl": "SPL", "z1khz": "Z1kHz", "z10khz": "Z10kHz"
            };

            for (const line of lines) {
                let cleanLine = line.replace(/[:=]/g, ' ').trim();
                if (!cleanLine) continue;

                // Pre-normalizzazione per chiavi complesse o con spazi
                // Es: "dB SPL" -> "dBSPL", "L 1kHz" -> "L1kHz"
                cleanLine = cleanLine.replace(/dB\s*SPL/gi, "dBSPL");
                cleanLine = cleanLine.replace(/L\s*1kHz/gi, "L1kHz");
                cleanLine = cleanLine.replace(/L\s*10kHz/gi, "L10kHz");
                cleanLine = cleanLine.replace(/Z\s*1kHz/gi, "Z1kHz");
                cleanLine = cleanLine.replace(/Z\s*10kHz/gi, "Z10kHz");

                // Splitta in token per whitespace
                const tokens = cleanLine.split(/\s+/);
                
                let currentKey = null;
                let valueAccumulator = [];

                for (const token of tokens) {
                    const lowerToken = token.toLowerCase();
                    
                    // Se il token √® una chiave conosciuta
                    if (keysMap.hasOwnProperty(lowerToken)) {
                        // Se avevamo una chiave aperta, salviamo il valore accumulato finora
                        if (currentKey) {
                            const fullValue = valueAccumulator.join(' ').trim();
                            if (fullValue) {
                                params[currentKey] = fullValue;
                            }
                        }
                        
                        // Inizia una nuova chiave
                        currentKey = keysMap[lowerToken];
                        valueAccumulator = [];
                    } else {
                        // Non √® una chiave, aggiungi al valore corrente se ne abbiamo una aperta
                        if (currentKey) {
                            valueAccumulator.push(token);
                        }
                    }
                }
                
                // Salvataggio finale per l'ultima chiave della riga
                if (currentKey && valueAccumulator.length > 0) {
                    const fullValue = valueAccumulator.join(' ').trim();
                    if (fullValue) {
                        params[currentKey] = fullValue;
                    }
                }
            }
            return params;
        }

        // Modificata per accettare dataType e content
        function addDataset(points, filename, dataType, content) {
            let tsParams = null;
            let hasTsParams = false;

            // Parso i TS se il contenuto √® presente
            if (content) {
                tsParams = parseTSContent(content);
                hasTsParams = Object.keys(tsParams).length > 0;
            }

            // Logica per unire i dati TS a un dataset esistente se il file attuale contiene solo TS (nessun punto grafico)
            // o se √® esplicitamente un file TS, evitando di creare una nuova riga.
            const isTsOnly = (points.length === 0 && hasTsParams);

            if (isTsOnly && datasets.length > 0) {
                console.log(`[Graph Viewer] Rilevati dati TS senza punti grafici. Tentativo di merge con dataset esistente.`);
                
                // Cerchiamo un dataset esistente a cui agganciare i dati TS.
                // Priorit√†: Ultimo dataset aggiunto che sia 'ohm' o 'db'.
                // L'utente vuole che vada nella riga RES o Impedenza.
                let targetIndex = -1;

                // Cerca dall'ultimo al primo
                for (let i = datasets.length - 1; i >= 0; i--) {
                    // Controlla se √® un dataset valido (non un altro placeholder vuoto, anche se la logica qui dovrebbe prevenirlo)
                    // Accettiamo qualsiasi dataset che abbia dei dati grafici o sia comunque una "curva" principale
                    if (datasets[i].data && datasets[i].data.length > 0) {
                        targetIndex = i;
                        break;
                    }
                }

                if (targetIndex !== -1) {
                    console.log(`[Graph Viewer] Merge TS effettuato su dataset analogo: ${datasets[targetIndex].label}`);
                    
                    // Merge dei parametri TS
                    datasets[targetIndex].tsParams = { ...datasets[targetIndex].tsParams, ...tsParams };
                    
                    // Aggiorno anche dataset originale
                    originalDatasets[targetIndex].tsParams = { ...originalDatasets[targetIndex].tsParams, ...tsParams };

                    // Aggiorna anche il contenuto testuale grezzo accodandolo, per completezza
                    if (content) {
                        datasets[targetIndex].tsContent = (datasets[targetIndex].tsContent || '') + '\n' + content;
                        originalDatasets[targetIndex].tsContent = (originalDatasets[targetIndex].tsContent || '') + '\n' + content;
                    }

                    // Aggiorna la tabella per mostrare i nuovi parametri TS
                    updateDatasetList();
                    
                    // Non aggiungiamo una nuova riga, usciamo.
                    return;
                }
            }

            const color = colors[nextColorIndex % colors.length];
            nextColorIndex++;
            
            let yAxisIDToUse = 'y'; // Default a 'y' (dBSPL)
            if (dataType === 'ohm') {
                yAxisIDToUse = 'yOhm';
            } else if (dataType === 'db') {
                yAxisIDToUse = 'y';
            }
            // Se dataType √® 'unknown' o 'ts', user√† 'y' ma per 'ts' i punti sono vuoti quindi non importa

            console.log(`[Graph Viewer] Aggiunta curva: ${filename}, Tipo dati: ${dataType}, Asse Y: ${yAxisIDToUse}`);

            const newDataset = {
                label: filename,
                data: points,
                backgroundColor: 'transparent',
                borderColor: color,
                borderWidth: 2,
                fill: false,
                tension: 0.1,
                yAxisID: yAxisIDToUse,
                pointRadius: 0,
                pointHoverRadius: 4,
                tsContent: content, // Memorizza il contenuto TS grezzo
                tsParams: tsParams, // Memorizza i parametri parsati
                showTS: false // Stato visualizzazione TS
            };
            
            // Aggiunge il dataset sia alla versione di lavoro che a quella originale
            datasets.push(newDataset);
            originalDatasets.push(JSON.parse(JSON.stringify(newDataset))); // Deep copy per i dati originali
            
            if (chartReady) {
                chart.data.datasets = datasets;
                requestAnimationFrame(() => {
                    updateAxesAndControlsVisibility(); // Aggiorna visibilit√† prima di chart.update()
                    chart.update();
                    updateDatasetList();
                });
            }
        }

        function updateDatasetList() {
            const tbody = document.getElementById('dataset-list-body');
            const headerRow = document.getElementById('dataset-header-row');
            tbody.innerHTML = '';
            
            // Aggiorna header: rimuovi colonne TS esistenti
            while (headerRow.children.length > 5) {
                headerRow.removeChild(headerRow.lastChild);
            }
            
            // Aggiungi colonne TS se necessario
            if (showTSColumns) {
                tsKeys.forEach(key => {
                    const th = document.createElement('th');
                    th.textContent = key;
                    th.style.padding = '4px';
                    th.style.borderLeft = '1px solid #555';
                    th.className = 'ts-col-header';
                    headerRow.appendChild(th);
                });
            }

            const fragment = document.createDocumentFragment();
            
            datasets.forEach((dataset, index) => {
                const tr = document.createElement('tr');
                tr.dataset.originalIndex = index;
                tr.style.borderBottom = '1px solid #3a4a5a';

                // Valore
                const tdVal = document.createElement('td');
                tdVal.className = 'dataset-value-cell';
                tdVal.style.padding = '4px';
                tdVal.style.fontFamily = 'monospace';
                tdVal.style.width = '70px';
                tdVal.style.textAlign = 'right';
                tr.appendChild(tdVal);

                // Colore
                const tdColor = document.createElement('td');
                tdColor.style.padding = '4px';
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.className = 'color-picker';
                colorInput.value = rgbToHex(dataset.borderColor);
                colorInput.style.backgroundColor = colorInput.value;
                colorInput.addEventListener('input', function() {
                    datasets[index].borderColor = this.value;
                    this.style.backgroundColor = this.value;
                    if (chart) chart.update();
                });
                tdColor.appendChild(colorInput);
                tr.appendChild(tdColor);

                // Nome
                const tdName = document.createElement('td');
                tdName.textContent = dataset.label;
                tdName.style.padding = '4px';
                tdName.style.whiteSpace = 'nowrap';
                tr.appendChild(tdName);

                // Visibilit√†
                const tdVis = document.createElement('td');
                tdVis.style.padding = '4px';
                const toggleBtn = document.createElement('button');
                toggleBtn.innerHTML = '<i class="fas fa-eye-slash"></i>';
                toggleBtn.title = 'Toggle visibility';
                toggleBtn.style.fontSize = '10px';
                toggleBtn.style.padding = '2px 6px';
                toggleBtn.style.backgroundColor = '#4a5a6a';
                toggleBtn.style.border = 'none';
                toggleBtn.style.color = 'white';
                toggleBtn.style.cursor = 'pointer';
                
                let isHidden = dataset.hidden;
                if (chart) {
                    const meta = chart.getDatasetMeta(index);
                    if (meta) isHidden = meta.hidden;
                }
                if (isHidden) {
                    toggleBtn.style.color = 'red';
                }
                toggleBtn.onclick = () => toggleDataset(index);
                tdVis.appendChild(toggleBtn);
                tr.appendChild(tdVis);

                // Elimina
                const tdDel = document.createElement('td');
                tdDel.style.padding = '4px';
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                removeBtn.title = 'Remove dataset';
                removeBtn.style.fontSize = '10px';
                removeBtn.style.padding = '2px 6px';
                removeBtn.style.backgroundColor = '#4a5a6a';
                removeBtn.style.border = 'none';
                removeBtn.style.color = 'white';
                removeBtn.style.cursor = 'pointer';
                removeBtn.onclick = () => removeDataset(index);
                tdDel.appendChild(removeBtn);
                tr.appendChild(tdDel);

                // Colonne TS
                if (showTSColumns) {
                    tsKeys.forEach(key => {
                        const td = document.createElement('td');
                        td.style.padding = '4px';
                        td.style.borderLeft = '1px solid #555';
                        td.style.fontFamily = 'monospace';
                        td.style.color = '#a0c0a0';
                        if (dataset.tsParams && dataset.tsParams[key]) {
                            td.textContent = dataset.tsParams[key];
                        } else {
                            td.textContent = '-';
                        }
                        tr.appendChild(td);
                    });
                }

                fragment.appendChild(tr);
            });
            
            tbody.appendChild(fragment);
        }

        document.getElementById('ts-toggle-btn').addEventListener('click', function() {
            showTSColumns = !showTSColumns;
            this.style.backgroundColor = showTSColumns ? '#2196F3' : '#4a5a6a';
            updateDatasetList();
        });

        function toggleDataset(index) {
            const meta = chart.getDatasetMeta(index);
            meta.hidden = !meta.hidden;
            datasets[index].hidden = meta.hidden; // Sincronizza anche l'oggetto dataset
            
            // Trova il bottone corretto usando l'indice originale
            const tbody = document.getElementById('dataset-list-body');
            const row = Array.from(tbody.children).find(child => parseInt(child.dataset.originalIndex) === index);
            
            if (row) {
                const toggleBtn = row.querySelector('button[title="Toggle visibility"]');
                if (toggleBtn) {
                    if (meta.hidden) {
                        toggleBtn.style.color = 'red';
                    } else {
                        toggleBtn.style.color = 'white';
                    }
                }
            }
            
            chart.update('none');

            if (lastMouseEvent) {
                chart.options.onHover(lastMouseEvent, [], chart);
            }
        }

        function removeDataset(index) {
            // Sincronizza lo stato hidden prima di rimuovere per preservarlo negli altri dataset
            if (chart) {
                datasets.forEach((ds, i) => {
                    const meta = chart.getDatasetMeta(i);
                    if (meta) ds.hidden = meta.hidden;
                });
            }

            datasets.splice(index, 1);
            originalDatasets.splice(index, 1); // Rimuove anche dai dati originali per mantenere l'allineamento
            
            if (chart) { // Verifica se chart esiste
                chart.data.datasets = datasets; // Assegna l'array modificato
                chart.update();
            }
            updateDatasetList();
            updateAxesAndControlsVisibility(); // Aggiorna la UI dopo la rimozione
        }

        document.getElementById('export-btn').addEventListener('click', function() {
            if (!chart) return;
            const canvas = chart.canvas;
            const ctx = canvas.getContext('2d');

            // Salva colori e stati originali
            // const originalChartBackgroundColor = chart.options.backgroundColor; // Rimosso, gestiremo lo sfondo manualmente per l'export
            const originalXTicksColor = chart.options.scales.x.ticks.color;
            const originalYTicksColor = chart.options.scales.y.ticks.color;
            const originalYOhmsTicksColor = chart.options.scales.yOhm ? chart.options.scales.yOhm.ticks.color : null;
            const originalXTitleColor = chart.options.scales.x.title.color;
            const originalYTitleColor = chart.options.scales.y.title.color;
            const originalYOhmsTitleColor = chart.options.scales.yOhm ? chart.options.scales.yOhm.title.color : null;
            const originalXGridColor = chart.options.scales.x.grid.color;
            const originalYGridColor = chart.options.scales.y.grid.color;
            const originalYOhmsGridDisplay = (chart.options.scales.yOhm && chart.options.scales.yOhm.grid) ? chart.options.scales.yOhm.grid.display : null;
            const originalYOhmsGridColor = (chart.options.scales.yOhm && chart.options.scales.yOhm.grid) ? chart.options.scales.yOhm.grid.color : null;
            
            const originalLegendDisplay = chart.options.plugins.legend.display;
            const originalLegendPosition = chart.options.plugins.legend.position;
            const originalLegendLabelsColor = chart.options.plugins.legend.labels.color;

            // Imposta i colori e le opzioni per l'esportazione
            // chart.options.backgroundColor = 'white'; // Rimosso, lo sfondo bianco verr√† disegnato manualmente
            chart.options.scales.x.ticks.color = '#000000';
            chart.options.scales.y.ticks.color = '#000000';
            if (chart.options.scales.yOhm) chart.options.scales.yOhm.ticks.color = '#000000';
            chart.options.scales.x.title.color = '#000000';
            chart.options.scales.y.title.color = '#000000';
            if (chart.options.scales.yOhm) chart.options.scales.yOhm.title.color = '#000000';
            chart.options.scales.x.grid.color = '#cccccc';
            chart.options.scales.y.grid.color = '#cccccc';
            if (chart.options.scales.yOhm && chart.options.scales.yOhm.grid) {
                if (chart.options.scales.yOhm.display) {
                    chart.options.scales.yOhm.grid.display = true;
                }
                chart.options.scales.yOhm.grid.color = '#cccccc';
            }

            // Configura e mostra la legenda per l'esportazione
            chart.options.plugins.legend.display = true;
            chart.options.plugins.legend.position = 'top'; // Posizione della legenda
            chart.options.plugins.legend.labels.color = '#000000'; // Colore del testo della legenda
            chart.options.plugins.legend.labels.usePointStyle = false; // Forza l'uso di rettangoli pieni invece di stili dei punti
            chart.options.plugins.legend.labels.boxWidth = 12; // Larghezza del box colorato
            chart.options.plugins.legend.labels.padding = 10; // Spaziatura


            chart.update('none'); // Aggiorna il grafico per applicare tutte le modifiche, inclusa la legenda

            // Disegna esplicitamente lo sfondo bianco DOPO l'aggiornamento del grafico e PRIMA di toDataURL
            ctx.save();
            ctx.globalCompositeOperation = 'destination-over'; // Disegna sotto il contenuto esistente
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            const link = document.createElement('a');
            link.download = 'graph.jpg'; // Nome file JPG
            link.href = canvas.toDataURL('image/jpeg', 1.0); // Esporta come JPG con qualit√† 1.0

            // Ripristina i colori e gli stati originali
            setTimeout(() => {
                // chart.options.backgroundColor = originalChartBackgroundColor; // Rimosso
                chart.options.scales.x.ticks.color = originalXTicksColor;
                chart.options.scales.y.ticks.color = originalYTicksColor;
                if (chart.options.scales.yOhm && originalYOhmsTicksColor !== null) chart.options.scales.yOhm.ticks.color = originalYOhmsTicksColor;
                chart.options.scales.x.title.color = originalXTitleColor;
                chart.options.scales.y.title.color = originalYTitleColor;
                if (chart.options.scales.yOhm && originalYOhmsTitleColor !== null) chart.options.scales.yOhm.title.color = originalYOhmsTitleColor;
                chart.options.scales.x.grid.color = originalXGridColor;
                chart.options.scales.y.grid.color = originalYGridColor;
                if (chart.options.scales.yOhm && chart.options.scales.yOhm.grid) {
                    if (originalYOhmsGridDisplay !== null) chart.options.scales.yOhm.grid.display = originalYOhmsGridDisplay;
                    if (originalYOhmsGridColor !== null) chart.options.scales.yOhm.grid.color = originalYOhmsGridColor;
                }

                chart.options.plugins.legend.display = originalLegendDisplay;
                chart.options.plugins.legend.position = originalLegendPosition;
                chart.options.plugins.legend.labels.color = originalLegendLabelsColor;
                // Ripristina anche usePointStyle se era stato salvato uno stato specifico, altrimenti Chart.js user√† il suo default.
                // Per sicurezza, se si vuole essere certi di ripristinare il comportamento di default di Chart.js per usePointStyle,
                // si potrebbe salvare chart.options.plugins.legend.labels.usePointStyle originale.
                // Se non era definito, Chart.js ha un suo default (spesso false per le linee).
                // Per ora, non lo ripristiniamo esplicitamente assumendo che il default di Chart.js sia OK per la visualizzazione normale.
                // Se necessario, aggiungere: chart.options.plugins.legend.labels.usePointStyle = originalUsePointStyle; (dopo averlo salvato)
                
                chart.update('none'); // Aggiorna per tornare allo stato originale
            }, 100);
            link.click();
        });

        document.getElementById('clear-btn').addEventListener('click', function() {
            datasets = [];
            if (chart) {
                chart.data.datasets = [];
                chart.update();
            }
            updateDatasetList();
            updateAxesAndControlsVisibility(); // Aggiorna la visibilit√† dopo aver pulito
        });

        function rgbToHex(rgb) {
            if (typeof rgb !== 'string') return '#000000'; // Fallback per input non validi
            const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
            }
            return rgb; 
        }

        function applySettings() {
            if (!chart) return;
            
            const freqMin = parseFloat(document.getElementById('freq-min').value);
            const freqMax = parseFloat(document.getElementById('freq-max').value);
            const dbMin = parseFloat(document.getElementById('db-min').value);
            const dbMax = parseFloat(document.getElementById('db-max').value);
            const dbScale = parseFloat(document.getElementById('db-scale').value);
            
            if (freqMin < freqMax) {
                 chart.options.scales.x.min = freqMin;
                 chart.options.scales.x.max = freqMax;
            }
            if (dbMin < dbMax) {
                chart.options.scales.y.min = dbMin;
                chart.options.scales.y.max = dbMax;
                chart.options.scales.y.ticks.stepSize = dbScale;
            }
            
            const ohmMin = parseFloat(document.getElementById('ohm-min').value);
            const ohmMax = parseFloat(document.getElementById('ohm-max').value);
            
            if (chart.options.scales.yOhm && ohmMin < ohmMax) {
                chart.options.scales.yOhm.min = ohmMin;
                chart.options.scales.yOhm.max = ohmMax;
            }
            chart.update();
        }

        ['freq-min', 'freq-max', 'db-min', 'db-max', 'ohm-min', 'ohm-max'].forEach(id => {
            document.getElementById(id).addEventListener('input', applySettings);
        });
        document.getElementById('db-scale').addEventListener('change', applySettings);

        document.getElementById('grid-toggle').addEventListener('change', function() {
            if (chart) {
                updateGridVisibility();
                chart.update();
            }
        });

        // Gestione ottimizzata dei messaggi dalla finestra principale
        function handleAppMessages(event) {
            if (!event.data) return;

            if (event.data.type === 'addGraph') {
                document.getElementById('loader').style.display = 'flex';
                requestAnimationFrame(() => {
                    try {
                        addDataset(event.data.points, event.data.filename, event.data.dataType, event.data.content);
                        setTimeout(() => {
                            document.getElementById('loader').style.display = 'none';
                        }, 300);
                    } catch (error) {
                        console.error('Error adding dataset:', error);
                        document.getElementById('loader').style.display = 'none';
                    }
                });
            } else if (event.data.type === 'areYouReady') {
                if (event.data.targetWindowName && (window.name !== event.data.targetWindowName)) {
                    return; 
                }
                if (chartReady && window.opener && typeof window.opener.postMessage === 'function') {
                    console.log('Graph viewer responding to areYouReady with graphViewerReady');
                    window.opener.postMessage({ type: 'graphViewerReady', windowName: window.name || 'graphViewer' }, '*');
                }
            }
        }
        window.addEventListener('message', handleAppMessages, { passive: true });

        window.addEventListener('DOMContentLoaded', () => {
            initChart();
            if (datasets.length === 0) {
                 document.getElementById('loader').style.display = 'none';
            }
            // Assicura che i label for siano corretti per i controlli della toolbar
            // Questo √® un workaround se i label non hanno l'attributo 'for'
            const toolbarLabels = document.querySelectorAll('.toolbar label');
            toolbarLabels.forEach(label => {
                const input = label.querySelector('input[type="number"], select, input[type="checkbox"]');
                if (input && input.id && !label.hasAttribute('for')) {
                    label.setAttribute('for', input.id);
                }
            });

            // Rendere il pannello dataset trascinabile
            const datasetPanel = document.querySelector('.dataset-controls');
            const datasetHeader = datasetPanel.querySelector('h4');
            
            if (datasetPanel && datasetHeader) {
                datasetHeader.style.cursor = 'move';
                datasetHeader.title = 'Drag to move';
                
                let isDragging = false;
                let startX, startY, startLeft, startTop;
                
                datasetHeader.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // Usa offsetLeft/Top che sono relativi al genitore posizionato (.chart-container)
                    startLeft = datasetPanel.offsetLeft;
                    startTop = datasetPanel.offsetTop;
                    
                    // Imposta right a auto per permettere il posizionamento tramite left
                    datasetPanel.style.right = 'auto';
                    
                    document.body.style.userSelect = 'none';
                });
                
                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;
                    
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    
                    datasetPanel.style.left = (startLeft + dx) + 'px';
                    datasetPanel.style.top = (startTop + dy) + 'px';
                });
                
                document.addEventListener('mouseup', function() {
                    isDragging = false;
                    document.body.style.userSelect = '';
                });
            }
        });
    </script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Gestione finestre floating per parametri
    function createFloatingWindow(title, content) {
        // Crea il contenitore della finestra
        const win = document.createElement('div');
        win.className = 'floating-window';
        win.style.position = 'fixed';
        // Posiziona la finestra in basso a destra con un offset progressivo verso sinistra
        const offset = document.querySelectorAll('.floating-window').length * 210;
        win.style.bottom = '80px'; // Sposta le finestre un po' pi√π in basso
        win.style.right = (80 + offset) + 'px'; // Sposta le finestre un po' a destra
        win.style.width = '200px'; // Larghezza dimezzata per default
        win.style.background = 'rgba(42, 58, 74, 0.9)'; // Sfondo uguale a quello del dataset
        win.style.border = '2px solid #2196F3';
        win.style.borderRadius = '8px';
        win.style.boxShadow = '0 4px 16px rgba(0,0,0,0.2)';
        win.style.zIndex = 9999;
        win.style.height = '300px'; // Imposta un'altezza fissa pi√π alta per tutte le finestre
        win.style.minHeight = '60px';
        win.style.resize = 'both';
        win.style.overflow = 'auto';

        // Header con titolo e pulsanti
        const header = document.createElement('div');
        header.style.cursor = 'move';
        header.style.background = 'rgba(33, 150, 243, 0.5)'; // Sfondo semi-trasparente per l'intestazione
        header.style.color = '#fff';
        header.style.padding = '8px 12px';
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.borderTopLeftRadius = '8px';
        header.style.borderTopRightRadius = '8px';

        const titleSpan = document.createElement('span');
        titleSpan.textContent = title;
        header.appendChild(titleSpan);

        // Pulsanti minimizza, font +/-, chiudi
        const btns = document.createElement('div');
        btns.style.display = 'flex';
        btns.style.gap = '8px';

        // Font size controls
        const fontMinusBtn = document.createElement('button');
        fontMinusBtn.textContent = 'A-';
        fontMinusBtn.title = 'Font smaller';
        fontMinusBtn.style.background = '#fff';
        fontMinusBtn.style.color = '#2196F3';
        fontMinusBtn.style.border = 'none';
        fontMinusBtn.style.fontWeight = 'bold';
        fontMinusBtn.style.fontSize = '14px';
        fontMinusBtn.style.cursor = 'pointer';
        fontMinusBtn.style.width = '28px';
        fontMinusBtn.style.height = '28px';
        fontMinusBtn.style.borderRadius = '50%';

        const fontPlusBtn = document.createElement('button');
        fontPlusBtn.textContent = 'A+';
        fontPlusBtn.title = 'Font bigger';
        fontPlusBtn.style.background = '#fff';
        fontPlusBtn.style.color = '#2196F3';
        fontPlusBtn.style.border = 'none';
        fontPlusBtn.style.fontWeight = 'bold';
        fontPlusBtn.style.fontSize = '14px';
        fontPlusBtn.style.cursor = 'pointer';
        fontPlusBtn.style.width = '28px';
        fontPlusBtn.style.height = '28px';
        fontPlusBtn.style.borderRadius = '50%';

        const minBtn = document.createElement('button');
        minBtn.textContent = '‚Äì';
        minBtn.title = 'Minimize';
        minBtn.style.background = '#fff';
        minBtn.style.color = '#2196F3';
        minBtn.style.border = 'none';
        minBtn.style.fontWeight = 'bold';
        minBtn.style.fontSize = '18px';
        minBtn.style.cursor = 'pointer';
        minBtn.style.width = '28px';
        minBtn.style.height = '28px';
        minBtn.style.borderRadius = '50%';

        const closeBtn = document.createElement('button');
        closeBtn.textContent = '√ó';
        closeBtn.title = 'Close';
        closeBtn.style.background = '#fff';
        closeBtn.style.color = '#2196F3';
        closeBtn.style.border = 'none';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.style.fontSize = '18px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.width = '28px';
        closeBtn.style.height = '28px';
        closeBtn.style.borderRadius = '50%';

        btns.appendChild(fontMinusBtn);
        btns.appendChild(fontPlusBtn);
        btns.appendChild(minBtn);
        btns.appendChild(closeBtn);
        header.appendChild(btns);

        win.appendChild(header);

        // Corpo della finestra
        const body = document.createElement('div');
        body.className = 'floating-body';
        body.style.padding = '12px';
        body.style.overflow = 'auto';
        body.style.maxHeight = '300px';
        body.style.background = 'rgba(42, 58, 74, 0.9)'; // Sfondo uguale a quello del dataset
        body.style.fontFamily = 'monospace';
        body.style.whiteSpace = 'pre-wrap';
        body.style.color = '#c0d0e0'; // Testo grigio chiaro uguale a quello del dataset
        let fontSize = 12; // Dimensione del carattere aumentata leggermente per default
        body.style.fontSize = fontSize + 'px';
        body.textContent = content;
        win.appendChild(body);

        // Font size controls
        fontMinusBtn.addEventListener('click', function() {
            fontSize = Math.max(8, fontSize - 2);
            body.style.fontSize = fontSize + 'px';
        });
        fontPlusBtn.addEventListener('click', function() {
            fontSize = Math.min(48, fontSize + 2);
            body.style.fontSize = fontSize + 'px';
        });

        // Minimizza
        minBtn.addEventListener('click', function() {
            if (body.style.display !== 'none') {
                body.style.display = 'none';
                minBtn.textContent = '+';
            } else {
                body.style.display = '';
                minBtn.textContent = '‚Äì';
            }
        });

        // Chiudi
        closeBtn.addEventListener('click', function() {
            win.remove();
        });

        // Drag & drop
        let isDragging = false, offsetX = 0, offsetY = 0;
        header.addEventListener('mousedown', function(e) {
            isDragging = true;
            const rect = win.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            document.body.style.userSelect = 'none';
        });
        document.addEventListener('mousemove', function(e) {
            if (isDragging) {
                win.style.left = (e.clientX - offsetX) + 'px';
                win.style.top = (e.clientY - offsetY) + 'px';
                win.style.right = 'auto';
                win.style.bottom = 'auto';
            }
        });
        document.addEventListener('mouseup', function() {
            isDragging = false;
            document.body.style.userSelect = '';
        });

        document.body.appendChild(win);
    }

    // Gestione postMessage
    window.addEventListener('message', function(event) {
        if (event.data && event.data.type === 'addFloatingText') {
            createFloatingWindow(event.data.filename, event.data.content);
        }
    });
});
</script>
</body>
</html>
